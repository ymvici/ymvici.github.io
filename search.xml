<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>typescript+vue知识点</title>
      <link href="2020/09/23/typescript-vue%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2020/09/23/typescript-vue%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Vue<span class="token punctuation">,</span> Prop<span class="token punctuation">,</span> Emit<span class="token punctuation">,</span> Component<span class="token punctuation">,</span> Watch<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">'vue-property-decorator'</span><span class="token punctuation">;</span></code></pre><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><blockquote><p>2.1.0 新增</p></blockquote><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p>例如：</p><pre><code>&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</code></pre><h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><p>父组件 $emitFa.vue</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>$emit子组件调用父组件的方法并传递数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>父组件数据：<span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#123;">&amp;#123;</span>msg<span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>emit-ch</span> <span class="token attr-name">@updateInfo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateInfo<span class="token punctuation">"</span></span> <span class="token attr-name">:sendData</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>emit-ch</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> emitCh <span class="token keyword">from</span> <span class="token string">'./$emitCh'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">'emitFa'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> emitCh <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      msg<span class="token punctuation">:</span> <span class="token string">'北京'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    updateInfo <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 点击子组件按钮时触发事件</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> data<span class="token punctuation">.</span>city <span class="token comment" spellcheck="true">// 改变了父组件的值</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>子组件 $emitCh.vue</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>train-city<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>父组件传给子组件的数据：<span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#123;">&amp;#123;</span>sendData<span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>select()<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>点击子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">'emitCh'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 相当于一个全局 ID，可以不写，写了可以提供更好的调试信息</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sendData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 用来接收父组件传给子组件的数据</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    select <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        city<span class="token punctuation">:</span> <span class="token string">'杭州'</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'updateInfo'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// select事件触发后，自动触发updateInfo事件</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h1 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h1><p>子组件：</p><pre><code>alertInfo() &#123;      console.log(&#39;子组件的输出方法&#39;)    &#125;</code></pre><p>父组件</p><p>index.html</p><pre><code>    &lt;prj-search-tool        :searchToolItems = &#39;searchToolItems&#39;        @getTableData = &#39;onSubmit111&#39;        ref = &#39;myChild&#39;    &gt;</code></pre><p>vue.html</p><pre><code>childFun() &#123;        (this.$refs[&quot;myChild&quot;] as prjSearchTool).alertInfo();    &#125;</code></pre><h1 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h1><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed :"></a><strong>计算属性computed :</strong></h2><ol><li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li><li><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p></li><li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p></li><li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><p><img src="https://s1.ax1x.com/2020/09/18/whd4FH.png"></p></li></ol><h2 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h2><ol><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p>watch支持异步；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p></li></ol><p>　　immediate：组件加载立即触发回调函数执行，</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p><p><img src="https://s1.ax1x.com/2020/09/18/whwlnK.png"></p><pre><code>input: string = &#39;&#39;    @Watch(&#39;input&#39;)    alertInfo() &#123;        if(this.input === &#39;&#39;)            alert(1)    &#125;</code></pre><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>子组件使用具名插槽</p><pre><code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</code></pre><p>父组件调用子组件时，定义插槽中内容</p><pre><code> &lt;template v-slot:header&gt;        &lt;p&gt;我是header&lt;/p&gt;      &lt;/template&gt;    &lt;template v-slot:footer&gt;        &lt;p&gt;我是footer&lt;/p&gt;      &lt;/template&gt;</code></pre><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p> 相较于常规的赋值方式,解构赋值最主要的是’解构’两个字,在赋值的过程中要清晰的知道等号右边的结构.</p><p> 先简单地看一下原来的赋值方式.</p><pre><code>var a=[1,2]　　</code></pre><p>分析一下这句代码的几个点:</p><p>(1)变量申明和赋值</p><pre><code>var a;a=[1,2]//你可以理解这两个操作是分开的,虽然是一句代码.声明变量都会出现变量名的提升(也就是是声明变量的这句代码会被提升到生效作用域的最前面),区别在于&#39;var&#39;声明的是全局变量,而&#39;let const&#39;声明的是块级作用域变量.</code></pre><p> (2)结构对应</p><pre><code>var a;a=[1,2];a=12;   a=&#123;name:&#39;小明&#39;,age:18&#125;</code></pre><p> 解构赋值</p><p>结合上面的的例子,假如我现在只想要{name:’小明’,age:18}这个对象中的’name’属性,原来的做法</p><pre><code>var a=&#123;name:&#39;小明&#39;,age:18&#125;console.log(a.name)</code></pre><p>   就需要通过点语法去获取,实际开发中,我们的数据很多时候是嵌套很多层的,所以就会出现类似’a.b.c.d’这类代码.看着让人头晕,而解构赋值就是解决这个问题的方案之一</p><p>基本用法</p><p><strong>(1)声明和赋值</strong></p><p>  <strong>数组</strong></p><pre><code>let [a] = [1];</code></pre><p>  对象</p><pre><code>let &#123;name&#125; = &#123;name:&#39;小明&#39;,age:18&#125;</code></pre><p>　{变量名}:变量名必须是对象中的属性名　</p><p><strong>(2)结构对应(重难点)</strong>　</p><p> 数组(要位不要名)　</p><p> 对象(要名不要位)</p><p> 完全解构　</p><p>​    <strong>数组:</strong></p><p>​     <strong>a:按顺序</strong></p><pre><code>let [a, b, c] = [1, 2, 3];console.log(a,b,c)//1,2,3这样赋值的语义是我知道右边是一个有三个元素的数字,所以我声明了一个数组,三个元素分别是a,b,c和右边的三个元素对应.所以a=1,b=2,c=3 </code></pre><p> 　 <strong>b:打乱顺序</strong></p><pre><code>let [a, c, b] = [1, 2, 3];console.log(a,b,c)//1,3,2因为三个变量的位置变了,所以其对应的元素(值)也就变量　　</code></pre><p>　<strong>对象:</strong></p><p>​    <strong>a:按顺序</strong></p><pre><code>let &#123;name,age&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,age)//小明,18</code></pre><p>  　<strong>b:打乱顺序</strong>　　</p><pre><code>let &#123;age,name&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,age)//小明,18</code></pre><p>　虽然变量的声明前后顺序变了,但是对象中的值没变,它最终还是根据属性名去找值,所以结果没变</p><p><strong>c:不存在的属性名</strong></p><pre><code>let &#123;name,sex&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,sex)//小明,undefined</code></pre><p>嵌套解构</p><p>  <strong>数组</strong>:</p><pre><code>let [a, [b,c], d] = [1, [2, 3], 4];console.log(a,b,c,d)//1,2,3,4//反正结构和位置一一对应就行了.</code></pre><p> <strong>对象</strong></p><pre><code>const obj=&#123;    man:&#123;      student:&#123;           name:&#39;小明&#39;,           age:18        &#125;   &#125;&#125;let &#123;man:&#123;student&#125;&#125; = obj //obj里面有个man,然后里面有个student,注意这一行代码里变量就只有一个student,并没有manconsole.log(man,student) // undefined,&#123;name:&#39;小明&#39;,age:18&#125;let &#123;man:&#123;student:&#123;name&#125;&#125;&#125; = obj //同理,逐层拿到最后的name值,而且也只有name这一个属性console.log(name) //小明//如何同时拿到嵌套的每层的数据let &#123;man,man:&#123;studengt&#125;,man:&#123;student:&#123;name&#125;&#125;&#125; = objconsole.log(man,student,name) //&#123;student:&#123;name:&#39;小明&#39;,age:18&#125;&#125;,&#123;name:&#39;小明&#39;,age:18&#125;,18</code></pre><p>不完全解构</p><pre><code>let [a, b] = [1, 2, 3];console.log(a,b,c)//1,2//这里变量只有两个,但是数组中元素有三个.这里还是根据位置对应原理就行.a表示数组中的第一个元素,b表示第2个.而第三个元素我不要.let [a, [b], d] = [1, [2, 3], 4];console.log(a,b,d)//1,2,4//嵌套解构同样也可以不完全解构,根据实际需要,需要哪个就解构赋值哪个let [, , c] = [1, 2, 3];console.log(c)//3//注意这里是完全解构,只不过前两个元素我虽然解构了,但是我不要.因为位置对应的关系,所以必须有两个占位的,才能拿到第三个.//放在这里是为了方便理解为啥前面两个明明不要还得写两个&#39;,&#39;</code></pre><p> 超量赋值(自己瞎编的词)　　</p><pre><code>let [a,b,c,d] = [1,2,3]onsole.log(a,b,c,d)//1,2,3,undefined//因为前三个元素都能对应找到,而第四个找不到,但是已经声明了,没有值.//对象同理,如果出现了对象中没有的属性就会得到undefined</code></pre><p><strong>(3)重命名(先取再重命名)</strong></p><p>  数组:我们上面说过,数组解构的时候只要注意位置对应就行了,名称啥的无所谓,你喜欢叫什么变量名就什么变量名</p><p>  对象:对象解构的时候是要属性名对应才能取到值.但是没有说取到值之后不能重命名啊.一定要取到值之后在命名　　</p><pre><code>let &#123;name:myName,age&#125; =&#123;name:&#39;小明&#39;,age:18&#125;//这里name:myName的意思是:取到name属性值,冒号后面的变量名没有花括号,意思是把我取到的值交给冒号后面的变量名,即&#39;myName&#39;.相当于把name变量重命名为myName//而student:&#123;name&#125;,同样是&#39;属性名:&#39;意思一样,取里面对应的属性,冒号后面还有花括号,所以再解构,取student里面的name属性console.log(name,myName,age)//undefined,小明,18</code></pre><p>　<strong>(4)默认值(先取再默认)</strong></p><p>​    数组</p><pre><code>let [a=0, b=0,c=10] = [1, 2];console.log(a,b,c) //1,2,10//这里a,b,c在左边都先给了个默认值,但是这里是超量解构,a和b都成功取到值,但是c没取到,所以最终是默认值10,如果没有默认值就是undefined</code></pre><p>对象</p><pre><code>let &#123;name:sex=&#39;男&#39;&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(sex)  //小明let &#123;name:&#123;sex=&#39;男&#39;&#125;&#125; = &#123;name:&#39;小明&#39;,age:18&#125;console.log(sex)  //男//这里刚好通过这两个例子区分一下重命名和嵌套</code></pre><p>  <strong>(5)字符串解构</strong></p><p>  字符串的解构可以理解为一维数组的解构,这在处理字符串的时候特别方便.</p><pre><code>let [a,b,c] =&#39;123&#39;console.log(a,b,c,typeof c)  //1,2,3,string   解构出来的是字符类型的数据　</code></pre><p>　长度</p><pre><code>let &#123;length:s&#125; =&#39;123&#39;console.log(s,typeof s) //3,number //同理,数组也有长度let &#123;length:s&#125; = [1,2,3]console,log(s,typeof s) //3,number</code></pre><p><strong>(6)函数参数自动解构</strong></p><pre><code>function look([x,y])&#123;console.log(x,y)&#125;look([1,2]) //1,2</code></pre><p>参数默认值陷阱单独再写一篇</p><p>  <strong>(7)先声明再赋值(少用)</strong></p><p>  <strong>数组</strong></p><pre><code>let a;let b;[a,b]=[1,2]console.log(a,b) //1,2</code></pre><p><strong>对象</strong></p><pre><code>let x;&#123;x&#125;=&#123;x:1,y:1&#125; //报错 主要还是大括号的原因,js在行首遇到&#123;&#125;会把它当做代码块执行,所以会报错.(&#123;x&#125;=&#123;x:1,y:1&#125;) //这样可以解决问题,但是尽量别引入(),问题会变得复杂</code></pre><p>到这里为止,解构赋值的日常使用没问题了,它带来了不少方便,但也会产生一些新bug,比如:let {data} =res 的写法,假如res里面并没有data属性,那就会undefined,所以还是得明确等号右边的解构.　</p><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>当刷新页面（这里的刷新页面指的是 –&gt; F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage页面关闭后就清除掉了，localstorage不会。 </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="2020/09/22/docker/"/>
      <url>2020/09/22/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p> 镜像看作类，把容器看作类实例化后的对象 </p><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h3><p>款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做！</p><p>现在：开发打包部署上线，一套流程做完！</p><p> java – jar（环境） — 打包项目带上环境（镜像） —- ( Docker仓库：商店）—-下载到为我们发布的镜像 —- 直接运行即可！ </p><h3 id="Docker解决方案"><a href="#Docker解决方案" class="headerlink" title="Docker解决方案"></a>Docker解决方案</h3><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) — 原来都是交叉的！</p><p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p>水果 生化武器</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><h3 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p><p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>他们将自己的技术（容器化技术）命名就是 Docker</p><p>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>2013年，Docker开源！</p><p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p><p>2014年4月9日，Docker1.0发布！</p><p>docker为什么这么火？十分的轻巧！</p><p>在容器技术出来之前，我们都是使用虚拟机技术！</p><p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p><p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><p>vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟<br>docker : 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</p><h3 id="聊聊Docker"><a href="#聊聊Docker" class="headerlink" title="聊聊Docker"></a>聊聊Docker</h3><p>Docker基于Go语言开发的！开源项目！</p><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><p>之前的虚拟机技术！</p><p><img src="G:\xmind&md\imgs\1591688800800.png" alt="1591688800800"></p><h4 id="虚拟机技术缺点："><a href="#虚拟机技术缺点：" class="headerlink" title="虚拟机技术缺点："></a>虚拟机技术缺点：</h4><p>1、 资源占用十分多</p><p>2、 冗余步骤多</p><p>3、 启动很慢！</p><h4 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a><strong>容器化技术</strong></h4><p> <strong>容器化技术不是模拟一个完整的操作系统</strong> </p><p><img src="G:\xmind&md\imgs\1591689239886.png" alt="1591689239886"></p><h4 id="比较Docker和虚拟机技术的不同："><a href="#比较Docker和虚拟机技术的不同：" class="headerlink" title="比较Docker和虚拟机技术的不同："></a>比较Docker和虚拟机技术的不同：</h4><p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件<br>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了<br>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p><h3 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h3><h4 id="1-应用更快速的交付和部署"><a href="#1-应用更快速的交付和部署" class="headerlink" title="1.应用更快速的交付和部署"></a>1.应用更快速的交付和部署</h4><p>传统：一对帮助文档，安装程序。</p><p>Docker：打包镜像发布测试一键运行。</p><h4 id="2-更便捷的升级和扩缩容"><a href="#2-更便捷的升级和扩缩容" class="headerlink" title="2.更便捷的升级和扩缩容"></a>2.更便捷的升级和扩缩容</h4><p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p><h4 id="3-更简单的系统运维"><a href="#3-更简单的系统运维" class="headerlink" title="3.更简单的系统运维"></a>3.更简单的系统运维</h4><p>在容器化之后，我们的开发，测试环境都是高度一致的</p><h4 id="4-更高效的计算资源利用"><a href="#4-更高效的计算资源利用" class="headerlink" title="4.更高效的计算资源利用"></a>4.更高效的计算资源利用</h4><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h3><p><img src="G:\xmind&md\imgs\1591689686866.png" alt="1591689686866"></p><p>**镜像(image):**类似一个模板，可以通过一个镜像来创建容器服务，tomcat==&gt;run==&gt;tomcat01容器(提供服务的)，可以通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。类似java中的类(镜像)和对象(容器)</p><p>**容器(contain):**可以独立运行一个或者一组应用，通过镜像创建。</p><p>基本命令：启动，停止，删除。</p><p>**仓库(repository):**就是存放镜像的地方。</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p> <em>1.卸载旧版本</em> </p><pre><code>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine  </code></pre><p> <em>2.需要的安装包</em> </p><pre><code>yum install -y yum-utils</code></pre><p> <em>3.设置镜像的仓库</em> </p><pre><code>yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的，不推荐#推荐使用阿里云的，非常快yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#更新yum软件包索引yum makecache fast</code></pre><p> <em>4.安装docker相关的 docker-ce 社区版 而ee是企业版</em> </p><pre><code>yum install docker-ce docker-ce-cli containerd.io</code></pre><p> <em>5. 启动docker</em> </p><pre><code>systemctl start docker</code></pre><p> <em>6. 使用docker version查看是否按照成功</em> </p><pre><code> docker version</code></pre><p> <em>7. 测试</em> </p><p>设置国内下载源</p><pre><code># vi /etc/docker/daemon.json&#123;    &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;systemctl restart docker.service</code></pre><pre><code>docker run hello-worlddocker exec -it 775c7c9ee1e1 /bin/bash  </code></pre><p> <em>8.查看一下下载的镜像</em>       </p><pre><code>docker images</code></pre><h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><pre><code>#1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io#2. 删除资源rm -rf /var/lib/docker# /var/lib/docker docker的默认</code></pre><h3 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h3><p><img src="G:\xmind&md\imgs\1591691509601.png" alt="1591691509601"></p><p> docker run 流程图 </p><p><img src="G:\xmind&md\imgs\1591691537760.png" alt="1591691537760"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="Docker是怎么工作的？"><a href="#Docker是怎么工作的？" class="headerlink" title="Docker是怎么工作的？"></a>Docker是怎么工作的？</h4><ul><li>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</li><li>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</li><li><img src="G:\xmind&md\imgs\1591691653610.png" alt="1591691653610"></li></ul><h4 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h4><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>docker利用的是宿主机的内核,而不需要Guest OS。</p><p>GuestOS： VM（虚拟机）里的的系统（OS）;<br>HostOS：物理机里的系统（OS）；</p><p><img src="G:\xmind&md\imgs\1591691833753.png" alt="1591691833753"></p><p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><pre><code>docker images 查看所有镜像</code></pre><p><img src="G:\xmind&md\imgs\1591692390070.png" alt="1591692390070"></p><pre><code>docker search mysql 搜索镜像docker pull mysql   下载镜像</code></pre><p><img src="G:\xmind&md\imgs\1591692754240.png" alt="1591692754240"></p><p><img src="G:\xmind&md\imgs\1591692801844.png" alt="1591692801844"></p><pre><code>docker rmi 删除镜像docker rmi -f $(docker images -aq) 删除全部镜像</code></pre><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><pre><code>docker pull centos</code></pre><h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><pre><code>docker run [可选参数] imagedocker run -it 470671670cac /bin/bashexit 退出容器Ctrl + P + Q 容器不停止退出docker ps 查看正在运行的容器docker rm 容器id 删除容器，不能删除正在运行的容器</code></pre><p><img src="G:\xmind&md\imgs\1591693427313.png" alt="1591693427313"></p><p><img src="G:\xmind&md\imgs\1591694744515.png" alt="1591694744515"></p><h3 id="常用的其他命令"><a href="#常用的其他命令" class="headerlink" title="常用的其他命令"></a>常用的其他命令</h3><pre><code>docker run -d centos 后台启动问题 docker ps ，发现centos停止了docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止</code></pre><p><img src="G:\xmind&md\imgs\1591695363396.png" alt="1591695363396"></p><p><img src="G:\xmind&md\imgs\1591695466426.png" alt="1591695466426"></p><h4 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h4><pre><code>docker inspect 容器id</code></pre><h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><pre><code>方式一：进入容器后打开一个新的终端，可以在里面操作docker exec -it 容器id bashShell方式二：进入容器正在执行的终端，不会启动新的进程docker attach 容器id</code></pre><h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><pre><code>docker cp 容器id：容器内路径 目的的主机路径Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</code></pre><p><img src="G:\xmind&md\imgs\1591748874380.png" alt="1591748874380"></p><pre><code>拷贝是一个手动过程，未来使用-v 卷的技术，可以实现自动更新主机的数据</code></pre><h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><h5 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h5><pre><code>利用docker安装nginx1.搜索nginx docker search nginx2.下载nginx docker pull nginx3.启动nginx docker run -d --name nginx01 -p 3344:80 nginx                   后台运行 起别名          将主机3344端口映射到容器80端口4.本机自测 curl localhost：33445.进入容器 docker exec -it ngnix01 /bin/bash</code></pre><h5 id="2-安装tomcat"><a href="#2-安装tomcat" class="headerlink" title="2.安装tomcat"></a>2.安装tomcat</h5><pre><code>1.docker pull tomcat2.docker run -rm --name tomcat01 -p 8099:8080 tomcat //测试完成后就删除，不建议使用3.curl localhost:8099 //因为是阉割版所以会报4044.docker exec -it tomcat01 /bin/bash 进入容器发现linux命令不全，tomcat中的webapps目录下没有网页5.cp -r webapps.dist/* webapps 将 webapps.dist的网页复制到webapps中</code></pre><h5 id="3-部署es-kibanas"><a href="#3-部署es-kibanas" class="headerlink" title="3.部署es+kibanas"></a>3.部署es+kibanas</h5><pre class=" language-shell"><code class="language-shell">1.docker pull elasticsearch 2.docker run -d -name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.23.docker stats 查看cpu状态4.增加内存限制，-e 环境配置修改docker run -d -name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2最多64兆，最大512兆</code></pre><pre><code>Xms 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。Xss 是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。</code></pre><p><img src="G:\xmind&md\imgs\1591753677271.png" alt="1591753677271"></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>portainer，docker图形化管理工具，提供一个后台面板供我们操作</p><pre><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><blockquote><p>软件包: 含 运行某个软件所需的所有的内容(代码,库,环境变量)</p><p>所有的应用,直接打包——-&gt;&gt;&gt;&gt;镜像</p></blockquote><h3 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h3><h4 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS (联合文件系统)"></a>UnionFS (联合文件系统)</h4><p>就是个文件,像git一样用版本控制纪录下,一次次叠加,呈现的是一个独立的文件—&gt;&gt;docker镜像</p><p>公用重复的东西(例如linux内核啊,这东西根本就不必重复下载 )</p><p>一层一层一层的构成UnionFS</p><p><strong>bootfs</strong> : bootloader(主引导加载) 包含boot加载器和内核 当boot加载完毕后整个内核就都在内存中了,此时内存的主导权就交给了内核,此时bootfs就会被卸载</p><p><strong>rootfs</strong> : 它在bootfs之上,包含各种不同的操作系统发行版,即:/dev/proc/etc等文件</p><p>这东西就是个精简再精简的iso文件.它只包含基本的命令,工具和程序库就ok了,</p><p>底层直接调用host的kernel，这就解释了为什么虚拟机与docker相比非常慢</p><p>因为虚拟机要加载bootfs这层文件,通过它来完成整个系统,但docker只需要寄生在宿主机上,用它的内核调用自己的rootfs文夹,完成,就ok了,,,,实现秒级启动</p><p><img src="G:\xmind&md\imgs\1591754978465.png" alt="1591754978465"></p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><pre><code>docker commit 提交容器成为一个新的副本docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]例如docker commit -m=&quot;add webapps&quot; -a=&quot;ks&quot; ******* tomcat02:[1.0]</code></pre><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>容器之间可以有一个数据共享的技术，在docker容器中产生的数据，同步到本地。</p><p>这就是卷技术，将我们容器内的目录挂载在linux上面。</p><p>为了容器的持久化和同步操作，容器间也是可以数据共享的。</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><pre><code>docker run -it -v /home/ceshi:/home centos /bin/bash双向绑定，主机修改，容器内部也同步改变；反过来也一样。</code></pre><p>测试配置，mysql</p><pre><code>docker pull mysql:5.7docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=z111111 -d mysql:tag例如：docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=z111111 -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql mysql:5.7</code></pre><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><h4 id="匿名加载"><a href="#匿名加载" class="headerlink" title="匿名加载"></a>匿名加载</h4><pre><code>-v 容器内路径docker run -d -P --name -v /etc/nginx nginx 只写了容器内的名字，没有写主机对应的目录</code></pre><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><pre><code>-v 卷名:容器内路径</code></pre><p><img src="G:\xmind&md\imgs\1591758838981.png" alt="1591758838981"></p><p>所有的docker容器内的卷，没有指定目录的情况下都是默认挂载在主机的”/var/lib/docker/volumes”目录下</p><p><img src="G:\xmind&md\imgs\1591759293224.png" alt="1591759293224"></p><h3 id="初识DockerFile"><a href="#初识DockerFile" class="headerlink" title="初识DockerFile"></a>初识DockerFile</h3><blockquote><p>方式二：使用DockerFile构建docker镜像的构建文件</p></blockquote><p><img src="G:\xmind&md\imgs\1591759751919.png" alt="1591759751919"></p><p><img src="G:\xmind&md\imgs\1591759841222.png" alt="1591759841222"></p><pre><code>使用docker inspect 容器ID查看挂载情况</code></pre><p><img src="G:\xmind&md\imgs\1591759954926.png" alt="1591759954926"></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>两个容器间数据共享</p><p><img src="G:\xmind&md\imgs\1591760154907.png" alt="1591760154907"></p><p><img src="G:\xmind&md\imgs\1591760339175.png" alt="1591760339175"></p><p>docker01的volume01、02挂载到了docker02容器内了。都是双向绑定、复制。父容器删除，子容器仍然有数据</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>用来构建docker镜像的文件</p><p>1.编写一个dockerfile文件</p><p>2.docker build构建成为一个镜像</p><p>3.docker run运行容器</p><p>4.docker push发布镜像</p><h3 id="docker构建过程"><a href="#docker构建过程" class="headerlink" title="docker构建过程"></a>docker构建过程</h3><p>基础知识：</p><p>1.保留关键字都必须大写字母</p><p>2.执行从上到下</p><p>3.#表示注释</p><p>4.每个指令都会创建提交一个新的镜像层并提交</p><p><img src="G:\xmind&md\imgs\1591761311841.png" alt="1591761311841"></p><p>docker是面向开发的，以后发布项目，做镜像需要编写dockerfile文件。</p><h3 id="docker指令"><a href="#docker指令" class="headerlink" title="docker指令"></a>docker指令</h3><p><img src="G:\xmind&md\imgs\1591761503342.png" alt="1591761503342"></p><p><img src="G:\xmind&md\imgs\1591767804838.png" alt="1591767804838"></p><h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><p>docker hub99%都是从FROM scratch开始的</p><pre><code>FROM scratchADD centos-7-x86_64-docker.tar.xz /LABEL \    org.label-schema.schema-version=&quot;1.0&quot; \    org.label-schema.name=&quot;CentOS Base Image&quot; \    org.label-schema.vendor=&quot;CentOS&quot; \    org.label-schema.license=&quot;GPLv2&quot; \    org.label-schema.build-date=&quot;20200504&quot; \    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \    org.opencontainers.image.vendor=&quot;CentOS&quot; \    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \    org.opencontainers.image.created=&quot;2020-05-04 00:00:00+01:00&quot;CMD [&quot;/bin/bash&quot;]</code></pre><h4 id="创建自己的centos镜像"><a href="#创建自己的centos镜像" class="headerlink" title="创建自己的centos镜像"></a>创建自己的centos镜像</h4><p>1.创建基本docker配置文件</p><pre><code>FROM centosMAINTAINER YMENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSEE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash</code></pre><p>2.构建自己的镜像</p><pre><code>docker build -f mydockerfile -t mycentos:0.1 .</code></pre><h5 id="CMD和ENTRYPOINT区别"><a href="#CMD和ENTRYPOINT区别" class="headerlink" title="CMD和ENTRYPOINT区别"></a>CMD和ENTRYPOINT区别</h5><p><img src="G:\xmind&md\imgs\1591769429417.png" alt="1591769429417"></p><p>使用entrypoint可以追加</p><h4 id="创建自己的tomca镜像"><a href="#创建自己的tomca镜像" class="headerlink" title="创建自己的tomca镜像"></a>创建自己的tomca镜像</h4><p>1.准备镜像文件tomcat压缩包，jdk的压缩包</p><p><img src="G:\xmind&md\imgs\1591770035554.png" alt="1591770035554"></p><p>2.编写dockerfile文件</p><p>add 会自动解压到local目录下</p><pre><code>FROM centosMAINTAINER YMADD jdk-12.0.2_linux-x64_bin.tar.gz /usr/local/ ADD apache-tomcat-9.0.24.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV  JAVA_HOME /usr/loacl/jdk12ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOEM/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.24ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.24ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.24/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.24/bin/logs/catalina.out</code></pre><p>3.运行dockerfile</p><pre><code>docker build -t diytomcat .</code></pre><h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><h2 id="Docker网络原理"><a href="#Docker网络原理" class="headerlink" title="Docker网络原理"></a>Docker网络原理</h2><h3 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h3><p>清空所有环境</p><pre><code>docker rm -f $(docker ps -aq)docker rmi -f $(docker images -aq)</code></pre><p><img src="G:\xmind&md\imgs\1591774220959.png" alt="1591774220959"></p><p>docker是如何处理容器网络连接的</p><p><img src="G:\xmind&md\imgs\1591774313193.png" alt="1591774313193"></p><p>每个容器docker会自动分配一个ip地址，主机可以ping通容器的ip。我们只要安装了docker，就会有一个网卡docker0，使用桥接模式连接网络，使用的技术是evth-pair。</p><p>容器带来的网卡都是一对的，veth-pair就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连。正是利用这个特性，veth-pair充当桥梁，连接各种虚拟网络设备。</p><p><img src="G:\xmind&md\imgs\1591775358978.png" alt="1591775358978"></p><p>当项目重启时，数据库ip就会发生改变，我们希望能通过服务名称来连接数据库。</p><pre><code>docker run -d -P --name tomcat03 --link tomcat02 tomcat这样就可以直接使用服务名ping通docker exec -it tomcat03 ping tomcat02</code></pre><p>本质就是–link在我们配置增加了一个172.18.0.3 tomcat02 2122123123dasd</p><p>现在不建议使用–link</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre><code>查看所有的docker网络</code></pre><p><img src="G:\xmind&md\imgs\1591776912996.png" alt="1591776912996"></p><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>bridge：桥接 docker(默认)</p><p>none：不配置网络</p><p>host： 和主机共享网络</p><p>container： 容器内网络</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>docker run -d -P -name tomcat01 tomcatdocker run -d -P -name tomcat01 --net bridge tomcat 默认添加docker0docker0特点：默认，域名不能访问，--link可以打通连接我们可以自定义一个网络--driver bridge桥接模式--subnet 192.168.0.0/16 子网地址--gateway 192.168.0.1 mynet 网关docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code></pre><p><strong>将镜像发布到自己创建的网络下</strong></p><pre><code>docker run -d -P --name tomcat01 --net mynet tomcat 这样就可以通过名字ping通</code></pre><p>优点：</p><p>不同集群使用不同网络，保证集群式安全和健康的</p><h3 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h3><p><img src="G:\xmind&md\imgs\1591778462206.png" alt="1591778462206"></p><p><img src="G:\xmind&md\imgs\1591778490187.png" alt="1591778490187"></p><pre><code>docker network connect [OPTIONS] NETWORK CONTAINER</code></pre><blockquote><p>测试打通 docker0下的tomcat01连接mynet下的tomcat-net-01</p><p>实质上是将tomcat01放到mynet网络下，使一个容器两个ip地址</p></blockquote><pre><code>docker network connect mynet tomcat01docker exec -it tomcat01 ping tomcat-net-01</code></pre><h2 id="IDEA整合docker"><a href="#IDEA整合docker" class="headerlink" title="IDEA整合docker"></a>IDEA整合docker</h2><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><h2 id="Docker-swarm"><a href="#Docker-swarm" class="headerlink" title="Docker swarm"></a>Docker swarm</h2><h2 id="CI-CD-Jenkins"><a href="#CI-CD-Jenkins" class="headerlink" title="CI\CD Jenkins"></a>CI\CD Jenkins</h2>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="2020/09/22/webpack/"/>
      <url>2020/09/22/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a>webpack 是什么</h2><p>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p><h2 id="webpack-五个核心概念"><a href="#webpack-五个核心概念" class="headerlink" title="webpack 五个核心概念"></a>webpack 五个核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>Loader 让 webpack 能够去处理那些非 JavaScript 文件(webpack 自身只理解JavaScript)</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</p><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>模式(Mode)指示 webpack 使用相应模式的配置。</p><table><thead><tr><th>选项</th><th>描述</th><th>特点</th></tr></thead><tbody><tr><td>development</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和NamedModulesPlugin。</td><td>能让代码本地调试运行的环境</td></tr><tr><td>production</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin,FlagIncludedChunksPlugin, ModuleConcatenationPlugin,NoEmitOnErrorsPlugin, OccurrenceOrderPlugin,SideEffectsFlagPlugin 和 TerserPlugin。</td><td>能让代码优化上线运行的环境d</td></tr></tbody></table><h2 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h2><pre><code>1. 运行指令：    开发环境：webpack ./src/index.js -o ./build/built.js --mode=development      webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js      整体打包环境，是开发环境    生产环境：webpack ./src/index.js -o ./build/built.js --mode=production      webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js      整体打包环境，是生产环境   2. 结论：    1. webpack能处理js/json资源，不能处理css/img等其他资源    2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~    3. 生产环境比开发环境多一个压缩js代码。</code></pre><h2 id="打包样式文件"><a href="#打包样式文件" class="headerlink" title="打包样式文件"></a>打包样式文件</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*  webpack.config.js  webpack的配置文件    作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）    所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs。*/</span><span class="token comment" spellcheck="true">// resolve用来拼接绝对路径的方法</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> resolve <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// webpack配置</span>  <span class="token comment" spellcheck="true">// 入口起点</span>  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 输出</span>  output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出文件名</span>    filename<span class="token punctuation">:</span> <span class="token string">'built.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 输出路径</span>    <span class="token comment" spellcheck="true">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span>    path<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// loader的配置</span>  module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token comment" spellcheck="true">// 详细loader配置</span>      <span class="token comment" spellcheck="true">// 不同文件必须配置不同loader处理</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 匹配哪些文件</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 使用哪些loader进行处理</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token comment" spellcheck="true">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span>          <span class="token comment" spellcheck="true">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span>          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span>          <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.less$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>          <span class="token string">'css-loader'</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 将less文件编译成css文件</span>          <span class="token comment" spellcheck="true">// 需要下载 less-loader和less</span>          <span class="token string">'less-loader'</span>        <span class="token punctuation">]</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// plugins的配置</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">// 详细plugins的配置</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 模式</span>  mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 开发模式</span>  <span class="token comment" spellcheck="true">// mode: 'production'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="webpack打包报错"><a href="#webpack打包报错" class="headerlink" title="webpack打包报错"></a>webpack打包报错</h3><pre><code>首先在项目根目录下创建名为：webpack.config.js文件const path = require(&#39;path&#39;)module.exports = &#123;    //指定入口，表示webpack要打包哪个文件    entry: path.join(__dirname,&#39;./src/main.js&#39;),    //指定出口，表示打包好的文件输出到哪个目录    output:&#123;        path:path.join(__dirname,&#39;./dist&#39;),        //指定输出文件的名称        filename:&#39;bundle1.js&#39;    &#125;&#125;</code></pre><p>下载依赖</p><blockquote><p>npm i css-loader style-loader -D</p></blockquote><p>这样就能打包css样式资源了</p><blockquote><p>npm i less less-loader -D</p></blockquote><p>可以打包less资源</p><h3 id="打包html文件"><a href="#打包html文件" class="headerlink" title="打包html文件"></a>打包html文件</h3><blockquote><p>npm i html-webpack-plugin -D</p></blockquote><pre><code> plugins: [    // plugins的配置    // html-webpack-plugin    // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）    // 需求：需要有结构的HTML文件    new HtmlWebpackPlugin(&#123;      // 复制 &#39;./src/index.html&#39; 文件，并自动引入打包输出的所有资源（JS/CSS）      template: &#39;./src/index.html&#39;    &#125;)  ]</code></pre><h3 id="打包图片资源"><a href="#打包图片资源" class="headerlink" title="打包图片资源"></a>打包图片资源</h3><pre><code>module: &#123;    rules: [      &#123;        test: /\.less$/,        // 要使用多个loader处理用use        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      &#125;,      &#123;        // 问题：默认处理不了html中img图片        // 处理图片资源        test: /\.(jpg|png|gif)$/,        // 使用一个loader        // 下载 url-loader file-loader        loader: &#39;url-loader&#39;,        options: &#123;          // 图片大小小于8kb，就会被base64处理          // 优点: 减少请求数量（减轻服务器压力）          // 缺点：图片体积会更大（文件请求速度更慢）          limit: 8 * 1024,          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs          // 解析时会出问题：[object Module]          // 解决：关闭url-loader的es6模块化，使用commonjs解析          esModule: false,          // 给图片进行重命名          // [hash:10]取图片的hash的前10位          // [ext]取文件原来扩展名          name: &#39;[hash:10].[ext]&#39;        &#125;      &#125;,      &#123;        test: /\.html$/,        // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）        loader: &#39;html-loader&#39;      &#125;    ]  &#125;</code></pre><h3 id="打包其他资源"><a href="#打包其他资源" class="headerlink" title="打包其他资源"></a>打包其他资源</h3><pre><code>module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]      &#125;,      // 打包其他资源(除了html/js/css资源以外的资源)      &#123;        // 排除css/js/html资源        exclude: /\.(css|js|html|less)$/,        loader: &#39;file-loader&#39;,        options: &#123;          name: &#39;[hash:10].[ext]&#39;        &#125;      &#125;    ]  &#125;</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;span class=&quot;iconfont icon-icon-test&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test2&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test3&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test1&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>js，css会被</p><pre><code>plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;)  ]</code></pre><p>自动引入</p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~</p><p>首先下载依赖， npm i webpack-dev-server -D</p><pre><code> mode: &#39;development&#39;,  // 开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）  // 特点：只会在内存中编译打包，不会有任何输出  // 启动devServer指令为：npx webpack-dev-server  devServer: &#123;    // 项目构建后路径    contentBase: resolve(__dirname, &#39;build&#39;),    // 启动gzip压缩    compress: true,    // 端口号    port: 3000,    // 自动打开浏览器    open: true  &#125;</code></pre><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>webpack.config.js</p><pre><code>/*  开发环境配置：能让代码运行    运行项目指令：      webpack 会将打包结果输出出去      npx webpack-dev-server 只会在内存中编译打包，没有输出*/const &#123; resolve &#125; = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;  entry: &#39;./src/js/index.js&#39;,  output: &#123;    filename: &#39;js/built.js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;,  module: &#123;    rules: [      // loader的配置      &#123;        // 处理less资源        test: /\.less$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      &#125;,      &#123;        // 处理css资源        test: /\.css$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]      &#125;,      &#123;        // 处理图片资源        test: /\.(jpg|png|gif)$/,        loader: &#39;url-loader&#39;,        options: &#123;          limit: 8 * 1024,          name: &#39;[hash:10].[ext]&#39;,          // 关闭es6模块化          esModule: false,          outputPath: &#39;imgs&#39;        &#125;      &#125;,      &#123;        // 处理html中img资源        test: /\.html$/,        loader: &#39;html-loader&#39;      &#125;,      &#123;        // 处理其他资源        exclude: /\.(html|js|css|less|jpg|png|gif)/,        loader: &#39;file-loader&#39;,        options: &#123;          name: &#39;[hash:10].[ext]&#39;,          outputPath: &#39;media&#39;        &#125;      &#125;    ]  &#125;,  plugins: [    // plugins的配置    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;)  ],  mode: &#39;development&#39;,  devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true  &#125;&#125;;</code></pre><p>创建src目录，src下再创建index.html,index.js</p><h2 id="webpack-生产环境的基本配置"><a href="#webpack-生产环境的基本配置" class="headerlink" title="webpack 生产环境的基本配置"></a>webpack 生产环境的基本配置</h2><h3 id="提取-css-成单独文件"><a href="#提取-css-成单独文件" class="headerlink" title="提取 css 成单独文件"></a>提取 css 成单独文件</h3><blockquote><p>下载插件<br>npm install –save-dev mini-css-extract-plugin -D</p></blockquote><pre><code>const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [          // 创建style标签，将样式放入          // &#39;style-loader&#39;,           // 这个loader取代style-loader。作用：提取js中的css成单独文件          MiniCssExtractPlugin.loader,          // 将css文件整合到js文件中          &#39;css-loader&#39;        ]      &#125;    ]  &#125;，  plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;),    new MiniCssExtractPlugin(&#123;      // 对输出的css文件进行重命名      filename: &#39;css/built.css&#39;    &#125;)  ],</code></pre><h3 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h3><blockquote><p>下载依赖 npm i postcss-loader postcss-preset-env -D</p></blockquote><pre><code>module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          /*            css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式          */          // 使用loader的默认配置          // &#39;postcss-loader&#39;,          // 修改loader的配置          &#123;            loader: &#39;postcss-loader&#39;,            options: &#123;              ident: &#39;postcss&#39;,              plugins: () =&gt; [                // postcss的插件                require(&#39;postcss-preset-env&#39;)()              ]            &#125;          &#125;        ]      &#125;    ]  &#125;</code></pre><p>在package.json添加browserslist</p><pre><code>&quot;browserslist&quot;: &#123;    &quot;development&quot;: [   // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ],    &quot;production&quot;: [ // 生产环境：默认是看生产环境      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ]  &#125;</code></pre><p>在webpack.config.js设置node环境为开发环境</p><pre><code>process.env.NODE_ENV = &#39;development&#39;</code></pre><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><blockquote><p>下载安装包<br>npm install –save-dev optimize-css-assets-webpack-plugin</p></blockquote><pre><code>const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;),    new MiniCssExtractPlugin(&#123;      filename: &#39;css/built.css&#39;    &#125;),    // 压缩css    new OptimizeCssAssetsWebpackPlugin()  ]</code></pre><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><blockquote><p> 下载安装包<br>npm install –save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import -D</p></blockquote><pre><code>module: &#123;    rules: [      /*        语法检查： eslint-loader  eslint          注意：只检查自己写的源代码，第三方的库是不用检查的          设置检查规则：            airbnb --&gt; eslint-config-airbnb-base  eslint-plugin-import eslint      */      &#123;        test: /\.js$/,        exclude: /node_modules/, // 第三方的库是不用检查的        loader: &#39;eslint-loader&#39;,        options: &#123;          // 自动修复eslint的错误          fix: true        &#125;      &#125;    ]  &#125;</code></pre><p>package.json中eslintConfig中设置</p><pre><code>&quot;eslintConfig&quot;: &#123;    &quot;extends&quot;: &quot;airbnb-base&quot;,    &quot;env&quot;: &#123;      &quot;browser&quot;: true    &#125;  &#125;</code></pre><p>index.js</p><pre><code>// 下一行eslint所有规则都失效（下一行不进行eslint检查）// eslint-disable-next-lineconsole.log(add(2, 5));</code></pre><h3 id="js兼容性配置"><a href="#js兼容性配置" class="headerlink" title="js兼容性配置"></a>js兼容性配置</h3><p> 下载安装包<br>npm install –save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill core-js</p><pre><code>module: &#123;    rules: [      /*        js兼容性处理：babel-loader @babel/core           1. 基本js兼容性处理 --&gt; @babel/preset-env            问题：只能转换基本语法，如promise高级语法不能转换          2. 全部js兼容性处理 --&gt; @babel/polyfill              在index.js 下   import &#39;@babel/polyfill&#39;;            问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js      */        &#123;        test: /\.js$/,        exclude: /node_modules/,        loader: &#39;babel-loader&#39;,        options: &#123;          // 预设：指示babel做怎么样的兼容性处理          presets: [            [              &#39;@babel/preset-env&#39;,              &#123;                // 按需加载                useBuiltIns: &#39;usage&#39;,                // 指定core-js版本                corejs: &#123;                  version: 3                &#125;,                // 指定兼容性做到哪个版本浏览器                targets: &#123;                  chrome: &#39;60&#39;,                  firefox: &#39;60&#39;,                  ie: &#39;9&#39;,                  safari: &#39;10&#39;,                  edge: &#39;17&#39;                &#125;              &#125;            ]          ]        &#125;      &#125;    ]  &#125;</code></pre><h3 id="js的压缩"><a href="#js的压缩" class="headerlink" title="js的压缩"></a>js的压缩</h3><p>生产环境下会自动压缩js代码</p><h3 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h3><pre><code>plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;,      // 压缩html代码      minify: &#123;        // 移除空格        collapseWhitespace: true,        // 移除注释        removeComments: true      &#125;    &#125;)  ]</code></pre><h3 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h3><pre><code>const &#123; resolve &#125; = require(&#39;path&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); // 将css单独提取const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);// 定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV = &#39;production&#39;;// 复用loaderconst commonCssLoader = [ // css兼容配置  MiniCssExtractPlugin.loader,  &#39;css-loader&#39;,  &#123;    // 还需要在package.json中定义browserslist    loader: &#39;postcss-loader&#39;,    options: &#123;      ident: &#39;postcss&#39;,      plugins: () =&gt; [require(&#39;postcss-preset-env&#39;)()]    &#125;  &#125;];module.exports = &#123;  entry: &#39;./src/js/index.js&#39;,  output: &#123;    filename: &#39;js/built.js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [...commonCssLoader]      &#125;,      &#123;        test: /\.less$/,        use: [...commonCssLoader, &#39;less-loader&#39;]      &#125;,      /*        正常来讲，一个文件只能被一个loader处理。        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：          先执行eslint 在执行babel      */      &#123;        // 在package.json中eslintConfig --&gt; airbnb        test: /\.js$/,        exclude: /node_modules/,        // 优先执行        enforce: &#39;pre&#39;, //  先执行eslint 在执行babel        loader: &#39;eslint-loader&#39;,        options: &#123;          fix: true        &#125;      &#125;,      &#123;        test: /\.js$/,        exclude: /node_modules/,        loader: &#39;babel-loader&#39;,        options: &#123;          presets: [            [              &#39;@babel/preset-env&#39;,              &#123;                useBuiltIns: &#39;usage&#39;,                corejs: &#123;version: 3&#125;,                targets: &#123;                  chrome: &#39;60&#39;,                  firefox: &#39;50&#39;                &#125;              &#125;            ]          ]        &#125;      &#125;,      &#123;        test: /\.(jpg|png|gif)/,        loader: &#39;url-loader&#39;,        options: &#123;          limit: 8 * 1024,          name: &#39;[hash:10].[ext]&#39;,          outputPath: &#39;imgs&#39;,          esModule: false        &#125;      &#125;,      &#123;        test: /\.html$/,        loader: &#39;html-loader&#39;      &#125;,      &#123;        exclude: /\.(js|css|less|html|jpg|png|gif)/,        loader: &#39;file-loader&#39;,        options: &#123;          outputPath: &#39;media&#39;        &#125;      &#125;    ]  &#125;,  plugins: [    new MiniCssExtractPlugin(&#123; // 将css单独提取      filename: &#39;css/built.css&#39;    &#125;),    new OptimizeCssAssetsWebpackPlugin(),    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;,      minify: &#123;        collapseWhitespace: true,        removeComments: true      &#125;    &#125;)  ],  mode: &#39;production&#39;&#125;;</code></pre><pre><code>目前示例中webpack使用css方式：css-loader：将js中的css内容解析style-loader：最终将css样式通过&lt;style&gt;标签方式注入到页面中。CSS内容还是存储在JS文件中。MiniCssExtractPlugin 插件可以将CSS内容从打包结果中提取出来，存放到文件中。通过这个插件，就可以实现CSS模块的按需加载。因为提取后生成了css文件，所以就不需要&lt;style&gt;标签，而是直接通过&lt;link&gt;的方式引入。所以使用MiniCssExtractPlugin，就不需要style-loader，而是使用插件提供的loader实现通过&lt;link&gt;标签的方式注入。</code></pre><p> <a href="https://blog.csdn.net/astonishqft/article/details/82899965">https://blog.csdn.net/astonishqft/article/details/82899965</a> </p><h3 id="output中path、publicPath的区别"><a href="#output中path、publicPath的区别" class="headerlink" title="output中path、publicPath的区别"></a>output中path、publicPath的区别</h3><p>解决css提取出来后，img不加载问题</p><h2 id="webpack性能优化"><a href="#webpack性能优化" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h2><ul><li>开发环境性能优化</li><li>生产环境性能优化</li></ul><h3 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h3><ul><li>优化打包构建速度<ul><li>HMR</li></ul></li><li>优化代码调试<ul><li>source-map</li></ul></li></ul><h3 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h3><ul><li>优化打包构建速度<ul><li>oneOf</li><li>babel缓存</li><li>多进程打包</li><li>externals</li><li>dll</li></ul></li><li>优化代码运行的性能<ul><li>缓存(hash-chunkhash-contenthash)</li><li>tree shaking</li><li>code split</li><li>懒加载/预加载</li><li>pwa</li></ul></li></ul><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><p>HMR: hot module replacement 热模块替换 / 模块热替换<br>    作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 极大提升构建速度</p><p>  样式文件：可以使用HMR功能：因为style-loader内部实现了~<br>  js文件：默认不能使用HMR功能 –&gt; 需要修改js代码，添加支持HMR功能的代码<br>    注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。<br>    html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~ （不用做HMR功能）<br>    解决：修改entry入口，将html文件引入 </p><blockquote><p>entry: [‘./src/js/index.js’, ‘./src/index.html’],</p></blockquote><pre><code>devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true,    // 开启HMR功能    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务    hot: true  &#125;</code></pre><h4 id="index-js开启热更新"><a href="#index-js开启热更新" class="headerlink" title="index.js开启热更新"></a>index.js开启热更新</h4><pre><code>if (module.hot) &#123;  // 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效  module.hot.accept(&#39;./print.js&#39;, function() &#123;    // 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。    // 会执行后面的回调函数    print();  &#125;);</code></pre><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误</p><pre><code>devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true,    hot: true  &#125;,  devtool: &#39;eval-source-map&#39;</code></pre><pre><code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map    source-map：外部      错误代码准确信息 和 源代码的错误位置    inline-source-map：内联      只生成一个内联source-map      错误代码准确信息 和 源代码的错误位置    hidden-source-map：外部      错误代码错误原因，但是没有错误位置      不能追踪源代码错误，只能提示到构建后代码的错误位置    eval-source-map：内联      每一个文件都生成对应的source-map，都在eval      错误代码准确信息 和 源代码的错误位置    nosources-source-map：外部      错误代码准确信息, 但是没有任何源代码信息    cheap-source-map：外部      错误代码准确信息 和 源代码的错误位置       只能精确的行    cheap-module-source-map：外部      错误代码准确信息 和 源代码的错误位置       module会将loader的source map加入    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快    开发环境：速度快，调试更友好      速度快(eval&gt;inline&gt;cheap&gt;...)        eval-cheap-souce-map        eval-source-map      调试更友好          souce-map        cheap-module-souce-map        cheap-souce-map      --&gt; eval-source-map  / eval-cheap-module-souce-map    生产环境：源代码要不要隐藏? 调试要不要更友好      内联会让代码体积变大，所以在生产环境不用内联      nosources-source-map 全部隐藏      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息      --&gt; source-map / cheap-module-souce-map</code></pre><h3 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h3><p>提升构建速度，所有loader只判断一次</p><pre><code>module: &#123;    rules: [      &#123;        // 在package.json中eslintConfig --&gt; airbnb        test: /\.js$/,        exclude: /node_modules/,        // 优先执行        enforce: &#39;pre&#39;,        loader: &#39;eslint-loader&#39;,        options: &#123;          fix: true        &#125;      &#125;,      &#123;        // 以下loader只会匹配一个        // 注意：不能有两个配置处理同一种类型文件        oneOf: [          &#123;            test: /\.css$/,            use: [...commonCssLoader]          &#125;,          &#123;            test: /\.less$/,            use: [...commonCssLoader, &#39;less-loader&#39;]          &#125;,          /*            正常来讲，一个文件只能被一个loader处理。            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：              先执行eslint 在执行babel          */          &#123;            test: /\.js$/,            exclude: /node_modules/,            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                [                  &#39;@babel/preset-env&#39;,                  &#123;                    useBuiltIns: &#39;usage&#39;,                    corejs: &#123;version: 3&#125;,                    targets: &#123;                      chrome: &#39;60&#39;,                      firefox: &#39;50&#39;                    &#125;                  &#125;                ]              ]            &#125;          &#125;,          &#123;            test: /\.(jpg|png|gif)/,            loader: &#39;url-loader&#39;,            options: &#123;              limit: 8 * 1024,              name: &#39;[hash:10].[ext]&#39;,              outputPath: &#39;imgs&#39;,              esModule: false            &#125;          &#125;,          &#123;            test: /\.html$/,            loader: &#39;html-loader&#39;          &#125;,          &#123;            exclude: /\.(js|css|less|html|jpg|png|gif)/,            loader: &#39;file-loader&#39;,            options: &#123;              outputPath: &#39;media&#39;            &#125;          &#125;        ]      &#125;    ]  &#125;</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="babel缓存"><a href="#babel缓存" class="headerlink" title="babel缓存"></a>babel缓存</h4><blockquote><p>cacheDirectory: true –&gt; 让第二次打包构建速度更快</p></blockquote><pre><code>&#123;            test: /\.js$/,            exclude: /node_modules/,            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                [                  &#39;@babel/preset-env&#39;,                  &#123;                    useBuiltIns: &#39;usage&#39;,                    corejs: &#123; version: 3 &#125;,                    targets: &#123;                      chrome: &#39;60&#39;,                      firefox: &#39;50&#39;                    &#125;                  &#125;                ]              ],              // 开启babel缓存              // 第二次构建时，会读取之前的缓存              cacheDirectory: true            &#125;          &#125;</code></pre><h4 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h4><pre><code>/*  服务器代码  启动服务器指令：    npm i nodemon -g    nodemon server.js    node server.js  访问服务器地址：    http://localhost:3000*/const express = require(&#39;express&#39;);const app = express();// express.static向外暴露静态资源// maxAge 资源缓存的最大时间，单位msapp.use(express.static(&#39;build&#39;, &#123; maxAge: 1000 * 3600 &#125;));app.listen(3000);</code></pre><h4 id="文件资源缓存"><a href="#文件资源缓存" class="headerlink" title="文件资源缓存"></a>文件资源缓存</h4><pre><code> hash: 每次wepack构建时会生成一个唯一的hash值。        问题: 因为js和css同时使用一个hash值。          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件） chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样        问题: js和css的hash值还是一样的          因为css是在js中被引入的，所以同属于一个chunkcontenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样          --&gt; 让代码上线运行缓存更好使用</code></pre><h3 id="tree-shaking-树摇"><a href="#tree-shaking-树摇" class="headerlink" title="tree shaking 树摇"></a>tree shaking 树摇</h3><pre><code>tree shaking：去除无用代码    前提：1. 必须使用ES6模块化  2. 开启production环境    作用: 减少代码体积    在package.json中配置       &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）        问题：可能会把css / @babel/polyfill （副作用）文件干掉      &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code></pre><h3 id="code-split代码分割"><a href="#code-split代码分割" class="headerlink" title="code split代码分割"></a>code split代码分割</h3><pre><code>// 单入口  // entry: &#39;./src/js/index.js&#39;,  entry: &#123;    // 多入口：有一个入口，最终输出就有一个bundle    index: &#39;./src/js/index.js&#39;,    test: &#39;./src/js/test.js&#39;  &#125;,  output: &#123;    // [name]：取文件名    filename: &#39;js/[name].[contenthash:10].js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;</code></pre><blockquote><p>第二种配置</p></blockquote><pre><code>/*    1. 可以将node_modules中代码单独打包一个chunk最终输出    2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk  */  optimization: &#123;    splitChunks: &#123;      chunks: &#39;all&#39;    &#125;  &#125;,</code></pre><h3 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h3><pre><code>document.getElementById(&#39;btn&#39;).onclick = function() &#123;  // 懒加载~：当文件需要使用时才加载~  // 预加载 prefetch：会在使用之前，提前加载js文件   // 正常加载可以认为是并行加载（同一时间加载多个文件）    // 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源  import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./test&#39;).then((&#123; mul &#125;) =&gt; &#123;    console.log(mul(4, 5));  &#125;);&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="2020/09/21/test/"/>
      <url>2020/09/21/test/</url>
      
        <content type="html"><![CDATA[<h1 id="prjSearchTool组件"><a href="#prjSearchTool组件" class="headerlink" title="prjSearchTool组件"></a>prjSearchTool组件</h1><p><strong>index.vue</strong></p><pre><code>&lt;template src=&quot;./index.html&quot;&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;Vue,Watch,Prop,Component&#125; from &#39;vue-property-decorator&#39;@Componentexport default class ReviewPreviewv extends Vue&#123;    @Prop(&#123; defalut: ()=&gt; []&#125;) readonly searchToolsItems!: any[]    //  当不传数据时默认为空数组    formInline: object = &#123;&#125;    create() &#123;        console.log(this.searchToolItems)    &#125;    @Emit(&#39;getTableData&#39;)    onSubmit() &#123;        return this.formInline    &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; src=&quot;./index.scss&quot;&gt;</code></pre><p><strong>index.html</strong></p><pre><code> &lt;div&gt;     &lt;el-form :inline=&quot;true&quot; :model=&quot;formInline&quot; class=&quot;demo-form-inline&quot;&gt;         &lt;el-form-item             v-for = &quot;item in searchToolItems&quot;             :key = &quot;item.prop&quot;             :label = &quot;item.label&quot;         &gt;             &lt;el-select                 v-if = &quot;item.type === &#39;select&#39;&quot;                 v-model = &quot;formInline[item.prop]&quot;                 placeholder = &quot;请选择&quot;                 clearable             &gt;                 &lt;el-option                     v-for = &quot;option in item.options&quot;                     :key = &quot;option.value&quot;                     :value = &quot;option.value&quot;                 &gt;                 &lt;/el-option&gt;             &lt;/el-select&gt;             &lt;el-input                 v-else-if = &quot;item.type === &#39;input&#39;&quot;                 v-model = &quot;fromInline[item.prop]&quot;                 placehodler                 clearable             &gt;             &lt;/el-input&gt;         &lt;/el-form-item&gt;         &lt;el-form-item&gt;             &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;查询&lt;/el-button&gt;         &lt;/el-form-item&gt;     &lt;/el-form&gt; &lt;/div&gt;</code></pre><h2 id="调用组件"><a href="#调用组件" class="headerlink" title="调用组件"></a>调用组件</h2><p>index.html</p><pre><code>&lt;div&gt;    &lt;prj-search-tool        :searchToolItems = &#39;searchToolItems&#39;        @getTableData = &#39;onSubmit&#39;    &gt;    &lt;/prj-search-tool&gt;&lt;/div&gt;</code></pre><p>index.vue</p><pre><code>&lt;template src=&quot;./index.html&quot;&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;Vue,Watch,Prop,Component&#125; from &#39;vue-property-decorator&#39;import &#123;searchToolItems&#125; from &#39;./mock.ts&#39;import PrjSearchTool from &#39;../../components/prjSearchTool/index.vue&#39;@Component(&#123;    &#39;prj-search-tool&#39;: PrjSearchTool&#125;)export default class ReviewPreviewv extends Vue&#123;    searchToolItems: any = searchToolItems    formInline: &#123;        faqiren: &#39;&#39;,        leixing: &#39;&#39;,        jieduan: &#39;&#39;,        zhuangtai: &#39;&#39;,        jiancheng: &#39;&#39;    &#125;    onSubmit(formInine) &#123;        console.log(formInline.faqiren)    &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; src=&quot;./index.scss&quot;&gt;</code></pre><p>mock.ts</p><pre><code>export const searchToolItems = [    &#123;        prop: &#39;faqiren&#39;,        label: &#39;发起人&#39;,        type: &#39;input&#39;    &#125;,    &#123;        prop: &#39;leixing&#39;,        label: &#39;产品类型&#39;,        type: &#39;select&#39;,        options: [            &#123;                value: &#39;111&#39;,                label: &#39;1111&#39;            &#125;,            &#123;                value: &#39;2222&#39;,                label: &#39;111&#39;            &#125;            ]    &#125;,    &#123;        prop: &#39;jiancheng&#39;,        label: &#39;项目简称&#39;,        type: &#39;input&#39;    &#125;]</code></pre><h1 id="覆盖组件中的具名插槽"><a href="#覆盖组件中的具名插槽" class="headerlink" title="覆盖组件中的具名插槽"></a>覆盖组件中的具名插槽</h1><pre><code>&lt;template slot = &#39;operate&#39;&gt;    &lt;el-dropdown split-button type=&#39;primary&#39; @click=&#39;elDownClick&#39; trigger = &#39;click&#39;&gt; 查看    &lt;el-dropdown-menu slot = &#39;dropdown&#39;&gt;        &lt;el-dropdown-item @click.native=&#39;elDownClick1&#39;&gt;1111&lt;/el-dropdown-item&gt;        &lt;el-dropdown-item @click.native=&#39;elDownClick2&#39;&gt;2222&lt;/el-dropdown-item&gt;    &lt;/el-dropdown-menu&gt;    &lt;/el-dropdown&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/21/hello-world/"/>
      <url>2020/09/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
