<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS_spring_API</title>
      <link href="2020/09/28/js-spring-api/"/>
      <url>2020/09/28/js-spring-api/</url>
      
        <content type="html"><![CDATA[<h1 id="JS中字符串的API"><a href="#JS中字符串的API" class="headerlink" title="JS中字符串的API"></a>JS中字符串的API</h1><h2 id="raw-ES6"><a href="#raw-ES6" class="headerlink" title="raw(ES6)"></a>raw(ES6)</h2><p>raw() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它是一个模板字符串的标签函数，作用类似于Python的r和C#的@字符串前缀，都是用来获取一个模板字符串的原始字面量。</p><p>语法： *String.raw(callSite, …substitutions)*，callSite即模板字符串的『调用点对象』，…substitutions表示任意个内插表达式对应的值，这里理解起来相当拗口，下面我将通俗的讲解它。</p><p>如下是python的字符串前缀r：</p><pre><code># 防止特殊字符串被转义print r&#39;a\nb\tc&#39; # 打印出来依然是 &quot;a\nb\tc&quot;# python中常用于正则表达式regExp = r&#39;(?&lt;=123)[a-z]+&#39;1234</code></pre><p>如下是String.raw作为前缀的用法：</p><pre><code>// 防止特殊字符串被转义String.raw`a\nb\tc`; // 输出为 &quot;a\nb\tc&quot;// 支持内插表达式let name = &quot;louis&quot;;String.raw`Hello \n $&#123;name&#125;`;  // &quot;Hello \n louis&quot;// 内插表达式还可以运算String.raw`1+2=$&#123;1+2&#125;,2*3=$&#123;2*3&#125;`; // &quot;1+2=3,2*3=6&quot;</code></pre><p>String.raw作为函数来调用的场景不太多，如下是用法：</p><pre><code>// 对象的raw属性值为字符串时，从第二个参数起，它们分别被插入到下标为0，1，2，...n的元素后面String.raw(&#123;raw: &#39;abcd&#39;&#125;, 1, 2, 3); // &quot;a1b2c3d&quot;// 对象的raw属性值为数组时，从第二个参数起，它们分别被插入到数组下标为0，1，2，...n的元素后面String.raw(&#123;raw: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&#125;, 1, 2, 3); // &quot;a1b2c3d&quot;</code></pre><p>那么怎么解释String.raw函数按照下标挨个去插入的特性呢？MDN上有段描述如下：</p><blockquote><p>In most cases, <code>String.raw()</code> is used with template strings. The first syntax mentioned above is only rarely used, because <strong>the JavaScript engine will call this with proper arguments for you</strong>, just like with other tag functions.</p></blockquote><p>这意味着，String.raw作为函数调用时，基本与ES6的tag标签模板一样。如下：</p><pre><code>// 如下是tag函数的实现function tag()&#123;  const array = arguments[0];  return array.reduce((p, v, i) =&gt; p + (arguments[i] || &#39;&#39;) + v);&#125;// 回顾一个simple的tag标签模板tag`Hello $&#123; 2 + 3 &#125; world $&#123; 2 * 3 &#125;`; // &quot;Hello 5 world 6&quot;// 其实就想当于如下调用tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 5, 6); // &quot;Hello 5 world 6&quot;</code></pre><p>因此String.raw作为函数调用时，不论对象的raw属性值是字符串还是数组，插槽都是天生的，下标为0，1，2，…n的元素后面都是插槽（不包括最后一个元素）。实际上，它相当于是这样的tag函数：</p><pre><code>function tag()&#123;  const array = arguments[0].raw;  if(array === undefined || array === null)&#123; // 这里可简写成 array == undefined    throw new TypeError(&#39;Cannot convert undefined or null to object&#39;);  &#125;  return array.reduce((p, v, i) =&gt; p + (arguments[i] || &#39;&#39;) + v);&#125;</code></pre><p>实际上，String.raw作为函数调用时，若第一个参数不是一个符合标准格式的对象，执行将抛出TypeError错误。</p><pre><code>String.raw(&#123;123: &#39;abcd&#39;&#125;, 1, 2, 3); // TypeError: Cannot convert undefined or null to object1</code></pre><p>目前只有Chrome v41+和Firefox v34+版本浏览器实现了该方法。</p><p>字符串原型方法分为两种，一种是html无关的方法，一种是html有关的方法。我们先看第一种。<strong>但是无论字符串方法如何厉害，都不至于强大到可以改变原字符串。</strong></p><h2 id="HTML无关的方法"><a href="#HTML无关的方法" class="headerlink" title="HTML无关的方法"></a><strong>HTML无关的方法</strong></h2><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a><strong>charAt</strong></h3><p>charAt() 方法返回字符串中指定位置的字符。</p><p>语法：<em>str.charAt(index)</em></p><p>index 为字符串索引（取值从0至length-1），如果超出该范围，则返回空串。</p><pre><code>console.log(&quot;Hello, World&quot;.charAt(8)); // o, 返回下标为8的字符串o1</code></pre><h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a><strong>charCodeAt</strong></h3><p>charCodeAt() 返回指定索引处字符的 Unicode 数值。</p><p>语法：<em>str.charCodeAt(index)</em></p><p>index 为一个从0至length-1的整数。如果不是一个数值，则默认为 0，如果小于0或者大于字符串长度，则返回 NaN。</p><p>Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样.</p><p>charCodeAt() 总是返回一个小于 65,536 的值。因为高位编码单元需要由一对字符来表示，为了查看其编码的完成字符，需要查看 charCodeAt(i) 以及 charCodeAt(i+1) 的值。如需更多了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype">fixedCharCodeAt</a>。</p><pre><code>console.log(&quot;Hello, World&quot;.charCodeAt(8)); // 111console.log(&quot;前端工程师&quot;.charCodeAt(2)); // 24037, 可见也可以查看中文Unicode编码12</code></pre><h6 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h6><p>concat() 方法将一个或多个字符串拼接在一起，组成新的字符串并返回。</p><p>语法：<em>str.concat(string2, string3, …)</em></p><pre><code>console.log(&quot;早&quot;.concat(&quot;上&quot;,&quot;好&quot;)); // 早上好1</code></pre><p>但是 concat 的性能表现不佳，强烈推荐使用赋值操作符（+或+=）代替 concat。”+” 操作符大概快了 concat 几十倍。（数据参考 <a href="http://jsperf.com/concat-vs-plus-vs-join">性能测试</a>）。</p><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><strong>indexOf</strong></h6><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><strong>lastIndexOf</strong></h6><p>indexOf() 方法用于查找子字符串在字符串中首次出现的位置，没有则返回 -1。该方法严格区分大小写，并且从左往右查找。而 lastIndexOf 则从右往左查找，其它与前者一致。</p><p>语法：<em>str.indexOf(searchValue [, fromIndex=0])<em>，</em>str.lastIndexOf(searchValue [, fromIndex=0])</em></p><p>searchValue 表示被查找的字符串，fromIndex 表示开始查找的位置，默认为0，如果小于0，则查找整个字符串，若超过字符串长度，则该方法返回-1，除非被查找的是空字符串，此时返回字符串长度。</p><pre><code>console.log(&quot;&quot;.indexOf(&quot;&quot;,100)); // 0console.log(&quot;IT改变世界&quot;.indexOf(&quot;世界&quot;)); // 4console.log(&quot;IT改变世界&quot;.lastIndexOf(&quot;世界&quot;)); // 4123</code></pre><h6 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare"></a><strong>localeCompare</strong></h6><p>localeCompare() 方法用来比较字符串，如果指定字符串在原字符串的前面则返回负数，否则返回正数或0，其中0 表示两个字符串相同。该方法实现依赖具体的本地实现，不同的语言下可能有不同的返回。</p><p>语法：<em>str.localeCompare(str2 [, locales [, options]])</em></p><pre><code>var str = &quot;apple&quot;;var str2 = &quot;orange&quot;;console.log(str.localeCompare(str2)); // -1console.log(str.localeCompare(&quot;123&quot;)); // 11234</code></pre><p>目前 Safari 浏览器暂不支持该方法，但Chrome v24+、Firefox v29+，IE11+ 和 Opera v15+ 都已实现了它。</p><h6 id="match"><a href="#match" class="headerlink" title="match"></a><strong>match</strong></h6><p>match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用<code>new RegExp(obj)</code>将其转换为正则表达式对象。</p><p>语法：<em>str.match(regexp)</em></p><p>该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null。</p><p><strong>描述</strong></p><ul><li>若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。</li><li>若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。</li></ul><p><strong>相关 RegExp 方法</strong></p><ul><li>若需测试字符串是否匹配正则，请参考 RegExp.test(str)。</li><li>若只需第一个匹配结果，请参考 RegExp.exec(str)。</li></ul><pre><code>var str = &quot;World Internet Conference&quot;;console.log(str.match(/[a-d]/i)); // [&quot;d&quot;, index: 4, input: &quot;World Internet Conference&quot;]console.log(str.match(/[a-d]/gi)); // [&quot;d&quot;, &quot;C&quot;, &quot;c&quot;]// RegExp 方法如下console.log(/[a-d]/gi.test(str)); // trueconsole.log(/[a-d]/gi.exec(str)); // [&quot;d&quot;, index: 4, input: &quot;World Internet Conference&quot;]123456</code></pre><p>由上可知，RegExp.test(str) 方法只要匹配到了一个字符也返回true。而RegExp.exec(str) 方法无论正则中有没有包含 g 标志，RegExp.exec将直接返回第一个匹配结果，且该结果同 str.match(regexp) 方法不包含 g 标志时的返回一致。</p><h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a><strong>replace</strong></h6><p>该方法在之前已经讲过，详细请参考 <a href="http://louiszhai.github.io/2015/12/11/js.replace/"><code>String.prototype.replace高阶技能</code></a> 。</p><h6 id="search"><a href="#search" class="headerlink" title="search"></a><strong>search</strong></h6><p>search() 方法用于测试字符串对象是否包含某个正则匹配，相当于正则表达式的 test 方法，且该方法比 match() 方法更快。如果匹配成功，search() 返回正则表达式在字符串中首次匹配项的索引，否则返回-1。</p><p>注意：<strong>search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。</strong></p><p>语法：<em>str.search(regexp)</em></p><pre><code>var str = &quot;abcdefg&quot;;console.log(str.search(/[d-g]/)); // 3, 匹配到子串&quot;defg&quot;,而d在原字符串中的索引为312</code></pre><p>search() 方法不支持全局匹配（正则中包含g参数），如下：</p><pre><code>console.log(str.search(/[d-g]/g)); // 3, 与无g参数时,返回相同1</code></pre><h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a><strong>slice</strong></h6><p>slice() 方法提取字符串的一部分，并返回新的字符串。该方法有些类似 Array.prototype.slice 方法。</p><p>语法：<em>str.slice(start, end)</em></p><p>首先 end 参数可选，start可取正值，也可取负值。</p><p>取正值时表示从索引为start的位置截取到end的位置（不包括end所在位置的字符，如果end省略则截取到字符串末尾）。</p><p>取负值时表示从索引为 length+start 位置截取到end所在位置的字符。</p><pre><code>var str = &quot;It is our choices that show what we truly are, far more than our abilities.&quot;;console.log(str.slice(0,-30)); // It is our choices that show what we truly areconsole.log(str.slice(-30)); // , far more than our abilities.123</code></pre><h6 id="split"><a href="#split" class="headerlink" title="split"></a><strong>split</strong></h6><p>split() 方法把原字符串分割成子字符串组成数组，并返回该数组。</p><p>语法：<em>str.split(separator, limit)</em></p><p>两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。</p><pre><code>var str = &quot;today is a sunny day&quot;;console.log(str.split()); // [&quot;today is a sunny day&quot;]console.log(str.split(&quot;&quot;)); // [&quot;t&quot;, &quot;o&quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;, &quot; &quot;, &quot;i&quot;, &quot;s&quot;, &quot; &quot;, &quot;a&quot;, &quot; &quot;, &quot;s&quot;, &quot;u&quot;, &quot;n&quot;, &quot;n&quot;, &quot;y&quot;, &quot; &quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;]console.log(str.split(&quot; &quot;)); // [&quot;today&quot;, &quot;is&quot;, &quot;a&quot;, &quot;sunny&quot;, &quot;day&quot;]1234</code></pre><p>使用limit限定返回的数组大小，如下：</p><pre><code>console.log(str.split(&quot; &quot;)); // [&quot;today&quot;]1</code></pre><p>使用正则分隔符（RegExp separator）， 如下：</p><pre><code>console.log(str.split(/\s*is\s*/)); // [&quot;today&quot;, &quot;a sunny day&quot;]1</code></pre><p>若正则分隔符里包含捕获括号，则括号匹配的结果将会包含在返回的数组中。</p><pre><code>console.log(str.split(/(\s*is\s*)/)); // [&quot;today&quot;, &quot; is &quot;, &quot;a sunny day&quot;]1</code></pre><h6 id="substr"><a href="#substr" class="headerlink" title="substr"></a><strong>substr</strong></h6><p>substr() 方法返回字符串指定位置开始的指定数量的字符。</p><p>语法：<em>str.substr(start[, length])</em></p><p>start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。</p><p>length 表示截取的字符长度。</p><pre><code>var str = &quot;Yesterday is history. Tomorrow is mystery. But today is a gift.&quot;;console.log(str.substr(47)); // today is a gift.console.log(str.substr(-16)); // today is a gift.123</code></pre><p>目前 Microsoft’s JScript 不支持 start 参数取负的索引，如需在 IE 下支持，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr#Description">Polyfill</a>。</p><h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a><strong>substring</strong></h6><p>substring() 方法返回字符串两个索引之间的子串。</p><p>语法：<em>str.substring(indexA[, indexB])</em></p><p>indexA、indexB 表示字符串索引，其中 indexB 可选，如果省略，则表示返回从 indexA 到字符串末尾的子串。</p><p><strong>描述</strong></p><p>substring 要截取的是从 indexA 到 indexB（不包含）之间的字符，符合以下规律：</p><ul><li>若 indexA == indexB，则返回一个空字符串；</li><li>若 省略 indexB，则提取字符一直到字符串末尾；</li><li>若 任一参数小于 0 或 NaN，则被当作 0；</li><li>若 任一参数大于 length，则被当作 length。</li></ul><p>而 如果 indexA &gt; indexB，则 substring 的执行效果就像是两个参数调换一般。比如：str.substring(0, 1) == str.substring(1, 0)</p><pre><code>var str = &quot;Get outside every day. Miracles are waiting everywhere.&quot;;console.log(str.substring(1,1)); // &quot;&quot;console.log(str.substring(0)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(-1)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(0,100)); // Get outside every day. Miracles are waiting everywhere.console.log(str.substring(22,NaN)); // Get outside every day.123456</code></pre><h6 id="toLocaleLowerCase"><a href="#toLocaleLowerCase" class="headerlink" title="toLocaleLowerCase"></a><strong>toLocaleLowerCase</strong></h6><h6 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a><strong>toLocaleUpperCase</strong></h6><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射。而toLocaleUpperCase() 方法则是转换成大写的值。</p><p>语法：<em>str.toLocaleLowerCase()</em>, <em>str.toLocaleUpperCase()</em></p><pre><code>console.log(&#39;ABCDEFG&#39;.toLocaleLowerCase()); // abcdefgconsole.log(&#39;abcdefg&#39;.toLocaleUpperCase()); // ABCDEFG12</code></pre><h6 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a><strong>toLowerCase</strong></h6><h6 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a><strong>toUpperCase</strong></h6><p>这两个方法分别表示将字符串转换为相应的小写，大写形式，并返回。如下：</p><pre><code>console.log(&#39;ABCDEFG&#39;.toLowerCase()); // abcdefgconsole.log(&#39;abcdefg&#39;.toUpperCase()); // ABCDEFG12</code></pre><h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><strong>toString</strong></h6><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a><strong>valueOf</strong></h6><p>这两个方法都是返回字符串本身。</p><p>语法：<em>str.toString()</em>, <em>str.valueOf()</em></p><pre><code>var str = &quot;abc&quot;;console.log(str.toString()); // abcconsole.log(str.toString()==str.valueOf()); // true123</code></pre><p>对于对象而言，toString和valueOf也是非常的相似，它们之间有着细微的差别，请尝试运行以下一段代码：</p><pre><code>var x = &#123;    toString: function () &#123; return &quot;test&quot;; &#125;,    valueOf: function () &#123; return 123; &#125;&#125;;console.log(x); // testconsole.log(&quot;x=&quot; + x); // &quot;x=123&quot;console.log(x + &quot;=x&quot;); // &quot;123=x&quot;console.log(x + &quot;1&quot;); // 1231console.log(x + 1); // 124console.log([&quot;x=&quot;, x].join(&quot;&quot;)); // &quot;x=test&quot;1234567891011</code></pre><p>当 “+” 操作符一边为数字时，对象x趋向于转换为数字，表达式会优先调用 valueOf 方法，如果调用数组的 join 方法，对象x趋向于转换为字符串，表达式会优先调用 toString 方法。</p><h6 id="trim"><a href="#trim" class="headerlink" title="trim"></a><strong>trim</strong></h6><p>trim() 方法清除字符串首尾的空白并返回。</p><p>语法：<em>str.trim()</em></p><pre><code>console.log(&quot; a b c &quot;.trim()); // &quot;a b c&quot;1</code></pre><p>trim() 方法是 ECMAScript 5.1 标准加入的，它并不支持IE9以下的低版本IE浏览器，如需支持，请参考以下兼容写法：</p><pre><code>if(!String.prototype.trim) &#123;  String.prototype.trim = function () &#123;    return this.replace(/^\s+|\s+$/g,&#39;&#39;);  &#125;;&#125;12345</code></pre><h6 id="codePointAt-ES6"><a href="#codePointAt-ES6" class="headerlink" title="codePointAt(ES6)"></a><strong>codePointAt(ES6)</strong></h6><p>codePointAt() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回使用UTF-16编码的给定位置的值的非负整数。</p><p>语法：<em>str.codePointAt(position)</em></p><pre><code>console.log(&quot;a&quot;.codePointAt(0)); // 97console.log(&quot;\u4f60\u597d&quot;.codePointAt(0)); // 2032012</code></pre><p>如需在老的浏览器中使用该方法，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt#Polyfill">Polyfill</a>。</p><h6 id="includes-ES6"><a href="#includes-ES6" class="headerlink" title="includes(ES6)"></a><strong>includes(ES6)</strong></h6><p>includes() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。</p><p>语法：<em>str.includes(subString [, position])</em></p><p>subString 表示要搜索的字符串，position 表示从当前字符串的哪个位置开始搜索字符串，默认值为0。</p><pre><code>var str = &quot;Practice makes perfect.&quot;;console.log(str.includes(&quot;perfect&quot;)); // trueconsole.log(str.includes(&quot;perfect&quot;,100)); // false123</code></pre><p>实际上，Firefox 18~39中该方法的名称为contains，由于<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1102219">bug 1102219</a>的存在，它被重命名为<code>includes()</code> 。目前只有Chrome v41+和Firefox v40+版本浏览器实现了它，如需在其它版本浏览器中使用该方法，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#%E5%A1%AB%E5%85%85">Polyfill</a>。</p><h6 id="endsWith-ES6"><a href="#endsWith-ES6" class="headerlink" title="endsWith(ES6)"></a><strong>endsWith(ES6)</strong></h6><p>endsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。</p><p>语法：<em>str.endsWith(substring [, position])</em></p><p>与contains 方法不同，position 参数的默认值为字符串长度。</p><pre><code>var str = &quot;Learn and live.&quot;;console.log(str.endsWith(&quot;live.&quot;)); // trueconsole.log(str.endsWith(&quot;Learn&quot;,5)); // true123</code></pre><p>同样目前只有 Firefox v17+版本实现了该方法。其它浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill">Polyfill</a>。</p><h6 id="normalize-ES6"><a href="#normalize-ES6" class="headerlink" title="normalize(ES6)"></a><strong>normalize(ES6)</strong></h6><p>normalize() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它会按照指定的 Unicode 正规形式将原字符串正规化。</p><p>语法：<em>str.normalize([form])</em></p><p>form 参数可省略，目前有四种 Unicode 正规形式，即 “NFC”、”NFD”、”NFKC” 以及 “NFKD”，form的默认值为 “NFC”。如果form 传入了非法的参数值，则会抛出 RangeError 错误。</p><pre><code>var str = &quot;\u4f60\u597d&quot;;console.log(str.normalize()); // 你好console.log(str.normalize(&quot;NFC&quot;)); // 你好console.log(str.normalize(&quot;NFD&quot;)); // 你好console.log(str.normalize(&quot;NFKC&quot;)); // 你好console.log(str.normalize(&quot;NFKD&quot;)); // 你好123456</code></pre><p>目前只有Chrome v34+和Firefox v31+实现了它。</p><h6 id="repeat-ES6"><a href="#repeat-ES6" class="headerlink" title="repeat(ES6)"></a><strong>repeat(ES6)</strong></h6><p>repeat() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它返回重复原字符串多次的新字符串。</p><p>语法：<em>str.repeat(count)</em></p><p>count 参数只能取大于等于0 的数字。若该数字不为整数，将自动转换为整数形式，若为负数或者其他值将报错。</p><pre><code>var str = &quot;A still tongue makes a wise head.&quot;;console.log(str.repeat(0)); // &quot;&quot;console.log(str.repeat(1)); // A still tongue makes a wise head.console.log(str.repeat(1.5)); // A still tongue makes a wise head.console.log(str.repeat(-1)); // RangeError:Invalid count value12345</code></pre><p>目前只有 Chrome v41+、Firefox v24+和Safari v9+版本浏览器实现了该方法。其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#%E5%A1%AB%E5%85%85">Polyfill</a>。</p><h6 id="startsWith-ES6"><a href="#startsWith-ES6" class="headerlink" title="startsWith(ES6)"></a><strong>startsWith(ES6)</strong></h6><p>startsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false。</p><p>语法：<em>str.startsWith(subString [, position])</em></p><pre><code>var str = &quot;Where there is a will, there is a way.&quot;;console.log(str.startsWith(&quot;Where&quot;)); // trueconsole.log(str.startsWith(&quot;there&quot;,6)); // true123</code></pre><p>目前以下版本浏览器实现了该方法，其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill">Polyfill</a>。</p><table><thead><tr><th align="center">Chrome</th><th align="center">Firefox</th><th align="center">Edge</th><th align="center">Opera</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">41+</td><td align="center">17+</td><td align="center">✔️</td><td align="center">28+</td><td align="center">9+</td></tr></tbody></table><p>其它<strong>非标准</strong>的方法暂时不作介绍，如需了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype">String.prototype</a> 中标注为感叹号的方法。</p><h5 id="HTML有关的方法"><a href="#HTML有关的方法" class="headerlink" title="HTML有关的方法"></a>HTML有关的方法</h5><p>常用的方法有 anchor，link 其它方法如 big、blink、bold、fixed、fontcolor、fontsize、italics、small、strike、sub、sup均已废除。</p><p>接下来我们将介绍 anchor 和 link 两个方法，其他废除方法不作介绍。</p><h6 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a><strong>anchor</strong></h6><p>anchor() 方法创建一个锚标签。</p><p>语法：<em>str.anchor(name)</em></p><p>name 指定被创建的a标签的name属性，使用该方法创建的锚点，将会成为 document.anchors 数组的元素。</p><pre><code>var str = &quot;this is a anchor tag&quot;;document.body.innerHTML = document.body.innerHTML + str.anchor(&quot;anchor1&quot;); // body末尾将会追加这些内容 &lt;a name=&quot;anchor1&quot;&gt;this is a anchor tag&lt;/a&gt;12</code></pre><h6 id="link"><a href="#link" class="headerlink" title="link"></a><strong>link</strong></h6><p>link() 方法同样创建一个a标签。</p><p>语法：<em>str.link(url)</em></p><p>url 指定被创建的a标签的href属性，如果url中包含特殊字符，将自动进行编码。例如 <code>&quot;</code> 会被转义为 <code>&amp;\quot</code>。 使用该方法创建的a标签，将会成为 document.links 数组中的元素。</p><pre><code>var str = &quot;百度&quot;;document.write(str.link(&quot;https://www.baidu.com&quot;)); // &lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;12</code></pre><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>部分字符串方法之间存在很大的相似性，要注意区分他们的功能和使用场景。如：</p><ul><li>substr 和 substring，都是两个参数，作用基本相同，两者第一个参数含义相同，但用法不同，前者可为负数，后者值为负数或者非整数时将隐式转换为0。前者第二个参数表示截取字符串的长度，后者第二个参数表示截取字符串的下标；同时substring第一个参数大于第二个参数时，执行结果同位置调换后的结果。</li><li>search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。</li></ul><p>另外，还记得吗？concat方法由于效率问题，不推荐使用。</p><p>通常，字符串中，常用的方法就charAt、indexOf、lastIndexOf、match、replace、search、slice、split、substr、substring、toLowerCase、toUpperCase、trim、valueof 等这些。熟悉它们的语法规则就能熟练地驾驭字符串。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js_Array_API</title>
      <link href="2020/09/27/js-array-api/"/>
      <url>2020/09/27/js-array-api/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript数组所有API全解密"><a href="#JavaScript数组所有API全解密" class="headerlink" title="JavaScript数组所有API全解密"></a>JavaScript数组所有API全解密</h1><p> <a href="http://louiszhai.github.io/2017/04/28/array/#Array%E6%9E%84%E9%80%A0%E5%99%A8">http://louiszhai.github.io/2017/04/28/array/#Array%E6%9E%84%E9%80%A0%E5%99%A8</a> </p><h3 id="Array构造器"><a href="#Array构造器" class="headerlink" title="Array构造器"></a>Array构造器</h3><p>Array构造器用于创建一个新的数组。通常，我们推荐使用对象字面量创建数组，这是一个好习惯，但是总有对象字面量乏力的时候，比如说，我想创建一个长度为8的空数组。请比较如下两种方式：</p><pre><code>// 使用Array构造器var a = Array(8); // [undefined × 8]// 使用对象字面量var b = [];b.length = 8; // [undefined × 8]</code></pre><p>Array构造器明显要简洁一些，当然你也许会说，对象字面量也不错啊，那么我保持沉默。</p><p>如上，我使用了<code>Array(8)</code>而不是<code>new Array(8)</code>，这会有影响吗？实际上，并没有影响，这得益于Array构造器内部对this指针的判断，<a href="http://ecma262-5.com/ELS5_HTML.htm#Section_15.4.1">ELS5_HTML规范</a>是这么说的：</p><blockquote><p>When <code>Array</code> is called as a function rather than as a constructor, it creates and initialises a new Array object. Thus the function call <code>Array(…)</code> is equivalent to the object creation expression <code>new Array(…)</code> with the same arguments.</p></blockquote><p>从规范来看，浏览器内部大致做了如下类似的实现：</p><pre><code>function Array()&#123;  // 如果this不是Array的实例，那就重新new一个实例  if(!(this instanceof arguments.callee))&#123;    return new arguments.callee();  &#125;&#125;</code></pre><p>上面，我似乎跳过了对Array构造器语法的介绍，没事，接下来我补上。</p><p>Array构造器根据参数长度的不同，有如下两种不同的处理：</p><ul><li>new Array(arg1, arg2,…)，参数长度为0或长度大于等于2时，传入的参数将按照顺序依次成为新数组的第0至N项（参数长度为0时，返回空数组）。</li><li>new Array(len)，当len不是数值时，处理同上，返回一个只包含len元素一项的数组；当len为数值时，根据如下<a href="http://ecma262-5.com/ELS5_HTML.htm#Section_15.4.2.2">规范</a>，len最大不能超过32位无符号整型，即需要小于2的32次方（len最大为<code>Math.pow(2,32) -1</code>或<code>-1&gt;&gt;&gt;0</code>），否则将抛出RangeError。</li></ul><blockquote><p>If the argument <em>len</em> is a Number and ToUint32(<em>len</em>) is equal to <em>len</em>, then the <code>length</code> property of the newly constructed object is set to ToUint32(<em>len</em>). If the argument len is a Number and ToUint32(<em>len</em>) is not equal to <em>len</em>, a <strong>RangeError</strong> exception is thrown.</p></blockquote><p>以上，请注意Array构造器对于单个数值参数的特殊处理，如果仅仅需要使用数组包裹📦 若干参数，不妨使用Array.of，具体请移步下一节。</p><h3 id="ES6新增的构造函数方法"><a href="#ES6新增的构造函数方法" class="headerlink" title="ES6新增的构造函数方法"></a><strong>ES6新增的构造函数方法</strong></h3><p>鉴于数组的常用性，ES6专门扩展了数组构造器<code>Array</code> ，新增2个方法：<code>Array.of</code>、<code>Array.from</code>。下面展开来聊。</p><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a><strong>Array.of</strong></h4><p>Array.of用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其它。它基本上与Array构造器功能一致，唯一的区别就在单个数字参数的处理上。如下：</p><pre><code>Array.of(8.0); // [8]Array(8.0); // [empty × 8]12</code></pre><p>参数为多个，或单个参数不是数字时，Array.of 与 Array构造器等同。</p><pre><code>Array.of(8.0, 5); // [8, 5]Array(8.0, 5); // [8, 5]Array.of(&#39;8&#39;); // [&quot;8&quot;]Array(&#39;8&#39;); // [&quot;8&quot;]12345</code></pre><p>因此，若是需要使用数组包裹元素，推荐优先使用Array.of方法。</p><p>目前，以下版本浏览器提供了对Array.of的支持。</p><table><thead><tr><th align="center">Chrome</th><th align="center">Firefox</th><th align="center">Edge</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">45+</td><td align="center">25+</td><td align="center">✔️</td><td align="center">9.0+</td></tr></tbody></table><p>即使其他版本浏览器不支持也不必担心，由于Array.of与Array构造器的这种高度相似性，实现一个polyfill十分简单。如下：</p><pre><code>if (!Array.of)&#123;  Array.of = function()&#123;    return Array.prototype.slice.call(arguments);  &#125;;&#125;12345</code></pre><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a><strong>Array.from</strong></h4><p>语法：<em>Array.from(arrayLike[, processingFn[, thisArg]])</em></p><p>Array.from的设计初衷是快速便捷的基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象创建一个新的数组实例，说人话就是，只要一个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。</p><p>从语法上看，Array.from拥有3个形参，第一个为类似数组的对象，必选。第二个为加工函数，新生成的数组会经过该函数的加工再返回。第三个为this作用域，表示加工函数执行时this的值。后两个参数都是可选的。我们来看看用法。</p><pre><code>var obj = &#123;0: &#39;a&#39;, 1: &#39;b&#39;, 2:&#39;c&#39;, length: 3&#125;;Array.from(obj, function(value, index)&#123;  console.log(value, index, this, arguments.length);  return value.repeat(3); //必须指定返回值，否则返回undefined&#125;, obj);12345</code></pre><p>执行结果如下：</p><p><a href="http://louiszhai.github.io/docImages/array01.png"><img src="http://louiszhai.github.io/docImages/array01.png" alt="Array.from执行结果"></a></p><p>可以看到加工函数的this作用域被obj对象取代，也可以看到加工函数默认拥有两个形参，分别为迭代器当前元素的值和其索引。</p><p>注意，一旦使用加工函数，必须明确指定返回值，否则将隐式返回undefined，最终生成的数组也会变成一个只包含若干个undefined元素的空数组。</p><p>实际上，如果不需要指定this，加工函数完全可以是一个箭头函数。上述代码可以简化如下：</p><pre><code>Array.from(obj, (value) =&gt; value.repeat(3));1</code></pre><p>除了上述obj对象以外，拥有迭代器的对象还包括这些：<code>String</code>，<code>Set</code>，<code>Map</code>，<code>arguments</code> 等，Array.from统统可以处理。如下所示：</p><pre><code>// StringArray.from(&#39;abc&#39;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]// SetArray.from(new Set([&#39;abc&#39;, &#39;def&#39;])); // [&quot;abc&quot;, &quot;def&quot;]// MapArray.from(new Map([[1, &#39;abc&#39;], [2, &#39;def&#39;]])); // [[1, &#39;abc&#39;], [2, &#39;def&#39;]]// 天生的类数组对象argumentsfunction fn()&#123;  return Array.from(arguments);&#125;fn(1, 2, 3); // [1, 2, 3]123456789101112</code></pre><p>到这你可能以为Array.from就讲完了，实际上还有一个重要的扩展场景必须提下。比如说生成一个从0到指定数字的新数组，Array.from就可以轻易的做到。</p><pre><code>Array.from(&#123;length: 10&#125;, (v, i) =&gt; i); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]1</code></pre><p>后面我们将会看到，利用数组的keys方法实现上述功能，可能还要简单一些。</p><p>目前，以下版本浏览器提供了对Array.from的支持。</p><table><thead><tr><th align="center">Chrome</th><th align="center">Firefox</th><th align="center">Edge</th><th align="center">Opera</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">45+</td><td align="center">32+</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">9.0+</td></tr></tbody></table><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a><strong>Array.isArray</strong></h3><p>顾名思义，Array.isArray用来判断一个变量是否数组类型。JS的弱类型机制导致判断变量类型是初级前端开发者面试时的必考题，一般我都会将其作为考察候选人第一题，然后基于此展开。在ES5提供该方法之前，我们至少有如下5种方式去判断一个值是否数组：</p><pre><code>var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === &#39;[object Array]&#39;;1234567891011</code></pre><p>以上，除了<code>Object.prototype.toString</code>外，其它方法都不能正确判断变量的类型。</p><p>要知道，代码的运行环境十分复杂，一个变量可能使用浑身解数去迷惑它的创造者。且看：</p><pre><code>var a = &#123;  __proto__: Array.prototype&#125;;// 分别在控制台试运行以下代码// 1.基于instanceofa instanceof Array; // true// 2.基于constructora.constructor === Array; // true// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a); // true// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype; // true123456789101112</code></pre><p>以上，4种方法将全部返回<code>true</code>，为什么呢？我们只是手动指定了某个对象的<code>__proto__</code>属性为<code>Array.prototype</code>，便导致了该对象继承了Array对象，这种毫不负责任的继承方式，使得基于继承的判断方案瞬间土崩瓦解。</p><p>不仅如此，我们还知道，Array是堆数据，变量指向的只是它的引用地址，因此每个页面的Array对象引用的地址都是不一样的。iframe中声明的数组，它的构造函数是iframe中的Array对象。如果在iframe声明了一个数组<code>x</code>，将其赋值给父页面的变量<code>y</code>，那么在父页面使用<code>y instanceof Array</code> ，结果一定是<code>false</code>的。而最后一种返回的是字符串，不会存在引用问题。实际上，多页面或系统之间的交互只有字符串能够畅行无阻。</p><p>鉴于上述的两点原因，故笔者推荐使用最后一种方法去撩面试官（别提是我说的），如果你还不信，这里恰好有篇文章跟我持有相同的观点：<a href="http://web.mit.edu/jwalden/www/isArray.html">Determining with absolute accuracy whether or not a JavaScript object is an array</a>。</p><p>相反，使用Array.isArray则非常简单，如下：</p><pre><code>Array.isArray([]); // trueArray.isArray(&#123;0: &#39;a&#39;, length: 1&#125;); // false12</code></pre><p>目前，以下版本浏览器提供了对Array.isArray的支持。</p><table><thead><tr><th align="center">Chrome</th><th align="center">Firefox</th><th align="center">IE</th><th align="center">Opera</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">5+</td><td align="center">4+</td><td align="center">9+</td><td align="center">10.5+</td><td align="center">5+</td></tr></tbody></table><p>实际上，通过<code>Object.prototype.toString</code>去判断一个值的类型，也是各大主流库的标准。因此Array.isArray的polyfill通常长这样：</p><pre><code>if (!Array.isArray)&#123;  Array.isArray = function(arg)&#123;    return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;  &#125;;&#125;12345</code></pre><h3 id="数组推导"><a href="#数组推导" class="headerlink" title="数组推导"></a><strong>数组推导</strong></h3><p>ES6对数组的增强不止是体现在api上，还包括语法糖。比如说<code>for of</code>，它就是借鉴其它语言而成的语法糖，这种基于原数组使用<code>for of</code>生成新数组的语法糖，叫做<strong>数组推导</strong>。<strong>数组推导最初起早在ES6的草案中，但在第27版（2014年8月）中被移除，目前只有Firefox v30+支持，推导有风险，使用需谨慎。</strong>所幸如今这些语言都还支持推导：CoffeeScript、Python、Haskell、Clojure，我们可以从中一窥端倪。这里我们以python的<code>for in</code>推导打个比方：</p><pre><code># python for in 推导a = [1, 2, 3, 4]print [i * i for i in a if i == 3] # [9]123</code></pre><p>如下是SpiderMonkey引擎（Firefox）之前基于ES4规范实现的数组推导(与python的推导十分相似)：</p><pre><code>[i * i for (i of a)] // [1, 4, 9, 16]1</code></pre><p>ES6中数组有关的<code>for of</code>在ES4的基础上进一步演化，for关键字居首，in在中间，最后才是运算表达式。如下：</p><pre><code>[for (i of [1, 2, 3, 4]) i * i] // [1, 4, 9, 16]1</code></pre><p>同python的示例，ES6中数组有关的<code>for of</code>也可以使用if语句：</p><pre><code>// 单个if[for (i of [1, 2, 3, 4]) if (i == 3) i * i] // [9]// 甚至是多个if[for (i of [1, 2, 3, 4]) if (i &gt; 2) if (i &lt; 4) i * i] // [9]1234</code></pre><p>更为强大的是，ES6数组推导还允许多重<code>for of</code>。</p><pre><code>[for (i of [1, 2, 3]) for (j of [10, 100]) i * j] // [10, 100, 20, 200, 30, 300]1</code></pre><p>甚至，数组推导还能够嵌入另一个数组推导中。</p><pre><code>[for (i of [1, 2, 3]) [for (j of [10, 100]) i * j] ] // [[10, 100], [20, 200], [30, 300]]1</code></pre><p>对于上述两个表达式，前者和后者唯一的区别，就在于后者的第二个推导是先返回数组，然后与外部的推导再进行一次运算。</p><p>除了多个数组推导嵌套外，ES6的数组推导还会为每次迭代分配一个新的作用域（目前Firefox也没有为每次迭代创建新的作用域）：</p><pre><code>// ES6规范[for (x of [0, 1, 2]) () =&gt; x][0]() // 0// Firefox运行[for (x of [0, 1, 2]) () =&gt; x][0]() // 21234</code></pre><p>通过上面的实例，我们看到使用数组推导来创建新数组比<code>forEach</code>，<code>map</code>，<code>filter</code>等遍历方法更加简洁，只是非常可惜，它不是标准规范。</p><p>ES6不仅新增了对Array构造器相关API，还新增了8个原型的方法。接下来我会在原型方法的介绍中穿插着ES6相关方法的讲解，请耐心往下读。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><strong>原型</strong></h3><p>继承的常识告诉我们，js中所有的数组方法均来自于Array.prototype，和其他构造函数一样，你可以通过扩展 <code>Array</code> 的 <code>prototype</code> 属性上的方法来给所有数组实例增加方法。</p><p>值得一说的是，Array.prototype本身就是一个数组。</p><pre><code>Array.isArray(Array.prototype); // trueconsole.log(Array.prototype.length);// 012</code></pre><p>以下方法可以进一步验证：</p><pre><code>console.log([].__proto__.length);// 0console.log([].__proto__);// [Symbol(Symbol.unscopables): Object]12</code></pre><p>有关Symbol(Symbol.unscopables)的知识，这里不做详述，具体请移步后续章节。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>数组原型提供的方法非常之多，主要分为三种，一种是会改变自身值的，一种是不会改变自身值的，另外一种是遍历方法。</p><p>由于 Array.prototype 的某些属性被设置为[[DontEnum]]，因此不能用一般的方法进行遍历，我们可以通过如下方式获取 Array.prototype 的所有方法：</p><pre><code>Object.getOwnPropertyNames(Array.prototype); // [&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;, &quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;, &quot;includes&quot;, &quot;entries&quot;, &quot;keys&quot;, &quot;concat&quot;]1</code></pre><h4 id="改变自身值的方法-9个"><a href="#改变自身值的方法-9个" class="headerlink" title="改变自身值的方法(9个)"></a><strong>改变自身值的方法(9个)</strong></h4><p>基于ES6，改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。</p><p>对于能改变自身值的数组方法，日常开发中需要特别注意，尽量避免在循环遍历中去改变原数组的项。接下来，我们一起来深入地了解这些方法。</p><h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a><strong>pop</strong></h5><p>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。</p><pre><code>var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];var item = array.pop();console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]console.log(item); // mouse1234</code></pre><p>由于设计上的巧妙，pop方法可以应用在类数组对象上，即 <code>鸭式辨型</code>. 如下：</p><pre><code>var o = &#123;0:&quot;cat&quot;, 1:&quot;dog&quot;, 2:&quot;cow&quot;, 3:&quot;chicken&quot;, 4:&quot;mouse&quot;, length:5&#125;var item = Array.prototype.pop.call(o);console.log(o); // Object &#123;0: &quot;cat&quot;, 1: &quot;dog&quot;, 2: &quot;cow&quot;, 3: &quot;chicken&quot;, length: 4&#125;console.log(item); // mouse1234</code></pre><p>但如果类数组对象不具有length属性，那么该对象将被创建length属性，length值为0。如下：</p><pre><code>var o = &#123;0:&quot;cat&quot;, 1:&quot;dog&quot;, 2:&quot;cow&quot;, 3:&quot;chicken&quot;, 4:&quot;mouse&quot;&#125;var item = Array.prototype.pop.call(o);console.log(array); // Object &#123;0: &quot;cat&quot;, 1: &quot;dog&quot;, 2: &quot;cow&quot;, 3: &quot;chicken&quot;, 4: &quot;mouse&quot;, length: 0&#125;console.log(item); // undefined1234</code></pre><h5 id="push"><a href="#push" class="headerlink" title="push"></a><strong>push</strong></h5><p>push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入。</p><p>语法：<em>arr.push(element1, …, elementN)</em></p><pre><code>var array = [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;];var i = array.push(&quot;golfball&quot;);console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;, &quot;golfball&quot;]console.log(i); // 61234</code></pre><p>同pop方法一样，push方法也可以应用到类数组对象上，如果length不能被转成一个数值或者不存在length属性时，则插入的元素索引为0，且length属性不存在时，将会创建它。</p><pre><code>var o = &#123;0:&quot;football&quot;, 1:&quot;basketball&quot;&#125;;var i = Array.prototype.push.call(o, &quot;golfball&quot;);console.log(o); // Object &#123;0: &quot;golfball&quot;, 1: &quot;basketball&quot;, length: 1&#125;console.log(i); // 11234</code></pre><p>实际上，push方法是根据length属性来决定从哪里开始插入给定的值。</p><pre><code>var o = &#123;0:&quot;football&quot;, 1:&quot;basketball&quot;,length:1&#125;;var i = Array.prototype.push.call(o,&quot;golfball&quot;);console.log(o); // Object &#123;0: &quot;football&quot;, 1: &quot;golfball&quot;, length: 2&#125;console.log(i); // 21234</code></pre><p>利用push根据length属性插入元素这个特点，可以实现数组的合并，如下：</p><pre><code>var array = [&quot;football&quot;, &quot;basketball&quot;];var array2 = [&quot;volleyball&quot;, &quot;golfball&quot;];var i = Array.prototype.push.apply(array,array2);console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;golfball&quot;]console.log(i); // 412345</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><strong>reverse</strong></h5><p>reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。</p><p>语法：<em>arr.reverse()</em></p><pre><code>var array = [1,2,3,4,5];var array2 = array.reverse();console.log(array); // [5,4,3,2,1]console.log(array2===array); // true1234</code></pre><p>同上，reverse 也是鸭式辨型的受益者，颠倒元素的范围受length属性制约。如下:</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:2&#125;;var o2 = Array.prototype.reverse.call(o);console.log(o); // Object &#123;0: &quot;b&quot;, 1: &quot;a&quot;, 2: &quot;c&quot;, length: 2&#125;console.log(o === o2); // true1234</code></pre><p>如果 length 属性小于2 或者 length 属性不为数值，那么原类数组对象将没有变化。即使 length 属性不存在，该对象也不会去创建 length 属性。特别的是，当 length 属性较大时，类数组对象的『索引』会尽可能的向 length 看齐。如下:</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;,length:100&#125;;var o2 = Array.prototype.reverse.call(o);console.log(o); // Object &#123;97: &quot;c&quot;, 98: &quot;b&quot;, 99: &quot;a&quot;, length: 100&#125;console.log(o === o2); // true1234</code></pre><h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a><strong>shift</strong></h5><p>shift()方法删除数组的第一个元素，并返回这个元素。如果是栈的话，这个过程就是栈底弹出。</p><p>语法：<em>arr.shift()</em></p><pre><code>var array = [1,2,3,4,5];var item = array.shift();console.log(array); // [2,3,4,5]console.log(item); // 11234</code></pre><p>同样受益于鸭式辨型，对于类数组对象，shift仍然能够处理。如下：</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;;var item = Array.prototype.shift.call(o);console.log(o); // Object &#123;0: &quot;b&quot;, 1: &quot;c&quot;, length: 2&#125;console.log(item); // a1234</code></pre><p>如果类数组对象length属性不存在，将添加length属性，并初始化为0。如下：</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;&#125;;var item = Array.prototype.shift.call(o);console.log(o); // Object &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2:&quot;c&quot; length: 0&#125;console.log(item); // undefined1234</code></pre><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a><strong>sort</strong></h5><p>sort()方法对数组元素进行排序，并返回这个数组。sort方法比较复杂，这里我将多花些篇幅来讲这块。</p><p>语法：<em>arr.sort([comparefn])</em></p><p>comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：</p><pre><code>var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];var array2 = array.sort();console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]console.log(array2 == array); // truearray = [10, 1, 3, 20];var array3 = array.sort();console.log(array3); // [1, 10, 20, 3]12345678</code></pre><p>如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：</p><ul><li>若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面；</li><li>若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；</li><li>若 comparefn(a, b) &gt; 0，那么a , b 将调换位置；</li></ul><p>如果数组元素为数字，则排序函数comparefn格式如下所示：</p><pre><code>function compare(a, b)&#123;  return a-b;&#125;123</code></pre><p>如果数组元素为非ASCII字符的字符串(如包含类似 e、é、è、a、ä 或中文字符等非英文字符的字符串)，则需要使用String.localeCompare。下面这个函数将排到正确的顺序。</p><pre><code>var array = [&#39;互&#39;,&#39;联&#39;,&#39;网&#39;,&#39;改&#39;,&#39;变&#39;,&#39;世&#39;,&#39;界&#39;];var array2 = array.sort();var array = [&#39;互&#39;,&#39;联&#39;,&#39;网&#39;,&#39;改&#39;,&#39;变&#39;,&#39;世&#39;,&#39;界&#39;]; // 重新赋值,避免干扰array2var array3 = array.sort(function (a, b) &#123;  return a.localeCompare(b);&#125;);console.log(array2); // [&quot;世&quot;, &quot;互&quot;, &quot;变&quot;, &quot;改&quot;, &quot;界&quot;, &quot;网&quot;, &quot;联&quot;]console.log(array3); // [&quot;变&quot;, &quot;改&quot;, &quot;互&quot;, &quot;界&quot;, &quot;联&quot;, &quot;世&quot;, &quot;网&quot;]12345678910</code></pre><p>如上，『互联网改变世界』这个数组，sort函数默认按照数组元素unicode字符串形式进行排序，然而实际上，我们期望的是按照拼音先后顺序进行排序，显然String.localeCompare 帮助我们达到了这个目的。</p><p>为什么上面测试中需要重新给array赋值呢，这是因为sort每次排序时改变的是数组本身，并且返回数组引用。如果不这么做，经过连续两次排序后，array2 和 array3 将指向同一个数组，最终影响我们测试。array重新赋值后就断开了对原数组的引用。</p><p>同上，sort一样受益于鸭式辨型，比如：</p><pre><code>var o = &#123;0:&#39;互&#39;,1:&#39;联&#39;,2:&#39;网&#39;,3:&#39;改&#39;,4:&#39;变&#39;,5:&#39;世&#39;,6:&#39;界&#39;,length:7&#125;;Array.prototype.sort.call(o,function(a, b)&#123;  return a.localeCompare(b);&#125;);console.log(o); // Object &#123;0: &quot;变&quot;, 1: &quot;改&quot;, 2: &quot;互&quot;, 3: &quot;界&quot;, 4: &quot;联&quot;, 5: &quot;世&quot;, 6: &quot;网&quot;, length: 7&#125;, 可见同上述排序结果一致12345</code></pre><p>注意：使用sort的鸭式辨型特性时，若类数组对象不具有length属性，它并不会进行排序，也不会为其添加length属性。</p><pre><code>var o = &#123;0:&#39;互&#39;,1:&#39;联&#39;,2:&#39;网&#39;,3:&#39;改&#39;,4:&#39;变&#39;,5:&#39;世&#39;,6:&#39;界&#39;&#125;;Array.prototype.sort.call(o,function(a, b)&#123;  return a.localeCompare(b);&#125;);console.log(o); // Object &#123;0: &quot;互&quot;, 1: &quot;联&quot;, 2: &quot;网&quot;, 3: &quot;改&quot;, 4: &quot;变&quot;, 5: &quot;世&quot;, 6: &quot;界&quot;&#125;, 可见并未添加length属性12345</code></pre><h6 id="使用映射改善排序"><a href="#使用映射改善排序" class="headerlink" title="使用映射改善排序"></a><strong>使用映射改善排序</strong></h6><p>comparefn 如果需要对数组元素多次转换以实现排序，那么使用map辅助排序将是个不错的选择。基本思想就是将数组中的每个元素实际比较的值取出来，排序后再将数组恢复。</p><pre><code>// 需要被排序的数组var array = [&#39;dog&#39;, &#39;Cat&#39;, &#39;Boy&#39;, &#39;apple&#39;];// 对需要排序的数字和位置的临时存储var mapped = array.map(function(el, i) &#123;  return &#123; index: i, value: el.toLowerCase() &#125;;&#125;)// 按照多个值排序数组mapped.sort(function(a, b) &#123;  return +(a.value &gt; b.value) || +(a.value === b.value) - 1;&#125;);// 根据索引得到排序的结果var result = mapped.map(function(el)&#123;  return array[el.index];&#125;);console.log(result); // [&quot;apple&quot;, &quot;Boy&quot;, &quot;Cat&quot;, &quot;dog&quot;]123456789101112131415</code></pre><h6 id="奇怪的chrome"><a href="#奇怪的chrome" class="headerlink" title="奇怪的chrome"></a><strong>奇怪的chrome</strong></h6><p>实际上，ECMAscript规范中并未规定具体的sort算法，这就势必导致各个浏览器不尽相同的sort算法，请看sort方法在Chrome浏览器下表现：</p><pre><code>var array = [&#123; n: &quot;a&quot;, v: 1 &#125;, &#123; n: &quot;b&quot;, v: 1 &#125;, &#123; n: &quot;c&quot;, v: 1 &#125;, &#123; n: &quot;d&quot;, v: 1 &#125;, &#123; n: &quot;e&quot;, v: 1 &#125;, &#123; n: &quot;f&quot;, v: 1 &#125;, &#123; n: &quot;g&quot;, v: 1 &#125;, &#123; n: &quot;h&quot;, v: 1 &#125;, &#123; n: &quot;i&quot;, v: 1 &#125;, &#123; n: &quot;j&quot;, v: 1 &#125;, &#123; n: &quot;k&quot;, v: 1 &#125;, ];array.sort(function (a, b) &#123;    return a.v - b.v;&#125;);for (var i = 0,len = array.length; i &lt; len; i++) &#123;    console.log(array[i].n);&#125;// f a c d e b g h i j k12345678</code></pre><p>由于v值相等，array数组排序前后应该不变，然而Chrome却表现异常，而其他浏览器(如IE 或 Firefox) 表现正常。</p><p>这是因为v8引擎为了高效排序(采用了不稳定排序)。即数组长度超过10条时，会调用另一种排序方法(快速排序)；而10条及以下采用的是插入排序，此时结果将是稳定的，如下：</p><pre><code>var array = [&#123; n: &quot;a&quot;, v: 1 &#125;, &#123; n: &quot;b&quot;, v: 1 &#125;, &#123; n: &quot;c&quot;, v: 1 &#125;, &#123; n: &quot;d&quot;, v: 1 &#125;, &#123; n: &quot;e&quot;, v: 1 &#125;, &#123; n: &quot;f&quot;, v: 1 &#125;, &#123; n: &quot;g&quot;, v: 1 &#125;, &#123; n: &quot;h&quot;, v: 1 &#125;, &#123; n: &quot;i&quot;, v: 1 &#125;, &#123; n: &quot;j&quot;, v: 1 &#125;,];array.sort(function (a, b) &#123;  return a.v - b.v;&#125;);for (var i = 0,len = array.length; i &lt; len; i++) &#123;  console.log(array[i].n);&#125;// a b c d e f g h i j12345678</code></pre><p>从a 到 j 刚好10条数据。</p><p>那么我们该如何规避Chrome浏览器的这种”bug”呢？其实很简单，只需略动手脚，改变排序方法的返回值即可，如下：</p><pre><code>// 由于快速排序会打乱值相同的元素的默认排序，因此我们需要先标记元素的默认位置array.forEach(function(v, k)&#123;  v.__index = k;&#125;);array.sort(function (a, b) &#123;  // 由于__index标记了初始顺序，这样的返回才保证了值相同元素的顺序不变，进而使得排序稳定  return a.v - b.v || a.__index - b.__index;&#125;);12345678</code></pre><p>使用数组的sort方法需要注意一点：各浏览器的针对sort方法内部算法实现不尽相同，排序函数尽量只返回-1、0、1三种不同的值，不要尝试返回true或false等其它数值，因为可能导致不可靠的排序结果。</p><h6 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h6><p>sort方法传入的排序函数如果返回布尔值会导致什么样的结果呢？</p><p>以下是常见的浏览器以及脚本引擎：</p><table><thead><tr><th align="left">Browser Name</th><th align="left">ECMAScript Engine</th></tr></thead><tbody><tr><td align="left">Internet Explorer 6 - 8</td><td align="left">JScript</td></tr><tr><td align="left">Internet Explorer 9 - 10</td><td align="left">Chakra</td></tr><tr><td align="left">Firefox</td><td align="left">SpiderMonkey, IonMonkey, TraceMonkey</td></tr><tr><td align="left">Chrome</td><td align="left">V8</td></tr><tr><td align="left">Safair</td><td align="left">JavaScriptCore(SquirrelFish Extreme)</td></tr><tr><td align="left">Opera</td><td align="left">Carakan</td></tr></tbody></table><p>分析以下代码，预期将数组元素进行升序排序：</p><pre><code>var array = [7, 6, 5, 4, 3, 2, 1, 0, 8, 9];var comparefn = function (x, y) &#123;  return x &gt; y;&#125;;array.sort(comparefn);12345</code></pre><p>代码中，comparefn 函数返回值为 bool 类型，并非为规范规定的 -1、0、1 值。那么执行此代码，各 JS 脚本引擎实现情况如何？</p><table><thead><tr><th align="left"></th><th align="left">输出结果</th><th align="left">是否符合预期</th></tr></thead><tbody><tr><td align="left">JScript</td><td align="left">[2, 3, 5, 1, 4, 6, 7, 0, 8, 9]</td><td align="left">否</td></tr><tr><td align="left">Carakan</td><td align="left">[0, 1, 3, 8, 2, 4, 9, 5, 6, 7]</td><td align="left">否</td></tr><tr><td align="left">Chakra &amp; JavaScriptCore</td><td align="left">[7, 6, 5, 4, 3, 2, 1, 0, 8, 9]</td><td align="left">否</td></tr><tr><td align="left">SpiderMonkey</td><td align="left">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td><td align="left">是</td></tr><tr><td align="left">V8</td><td align="left">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td><td align="left">是</td></tr></tbody></table><p><strong>根据表中数据可见，当数组内元素个数小于等于 10 时，现象如下：</strong></p><ul><li>JScript &amp; Carakan 排序结果有误</li><li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li><li>SpiderMonkey 返回了预期的正确结果</li><li>V8 暂时看起来排序正确</li></ul><p><strong>将数组元素扩大至 11 位，现象如下：</strong></p><pre><code>var array = [7, 6, 5, 4, 3, 2, 1, 0, 10, 9, 8];var comparefn = function (x, y) &#123;  return x &gt; y;&#125;;array.sort(comparefn);12345</code></pre><table><thead><tr><th align="left">JavaScript引擎</th><th align="left">输出结果</th><th align="left">是否符合预期</th></tr></thead><tbody><tr><td align="left">JScript</td><td align="left">[2, 3, 5, 1, 4, 6, 7, 0, 8, 9, 10]</td><td align="left">否</td></tr><tr><td align="left">Carakan</td><td align="left">[0, 1, 3, 8, 2, 4, 9, 5, 10, 6, 7]</td><td align="left">否</td></tr><tr><td align="left">Chakra &amp; JavaScriptCore</td><td align="left">[7, 6, 5, 4, 3, 2, 1, 0, 10, 8, 9]</td><td align="left">否</td></tr><tr><td align="left">IonMonkey</td><td align="left">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</td><td align="left">是</td></tr><tr><td align="left">V8</td><td align="left">[5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]</td><td align="left">否</td></tr></tbody></table><p><strong>根据表中数据可见，当数组内元素个数大于 10 时：</strong></p><ul><li>JScript &amp; Carakan 排序结果有误</li><li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li><li>SpiderMonkey 返回了预期的正确结果</li><li>V8 <strong>排序结果由正确转为不正确</strong></li></ul><h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a><strong>splice</strong></h5><p>splice()方法用新元素替换旧元素的方式来修改数组。它是一个常用的方法，复杂的数组操作场景通常都会有它的身影，特别是需要维持原数组引用时，就地删除或者新增元素，splice是最适合的。</p><p>语法：<em>arr.splice(start,deleteCount[, item1[, item2[, …]]])</em></p><p>start 指定从哪一位开始修改内容。如果超过了数组长度，则从数组末尾开始添加内容；如果是负值，则其指定的索引位置等同于 length+start (length为数组的长度)，表示从数组末尾开始的第 -start 位。</p><p>deleteCount 指定要删除的元素个数，若等于0，则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素总和，则start及之后的元素都将被删除。</p><p>itemN 指定新增的元素，如果缺省，则该方法只删除数组元素。</p><p>返回值 由原数组中被删除元素组成的数组，如果没有删除，则返回一个空数组。</p><p>下面来举栗子说明：</p><pre><code>var array = [&quot;apple&quot;,&quot;boy&quot;];var splices = array.splice(1,1);console.log(array); // [&quot;apple&quot;]console.log(splices); // [&quot;boy&quot;] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素array = [&quot;apple&quot;,&quot;boy&quot;];splices = array.splice(2,1,&quot;cat&quot;);console.log(array); // [&quot;apple&quot;, &quot;boy&quot;, &quot;cat&quot;]console.log(splices); // [], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为array = [&quot;apple&quot;,&quot;boy&quot;];splices = array.splice(-2,1,&quot;cat&quot;);console.log(array); // [&quot;cat&quot;, &quot;boy&quot;]console.log(splices); // [&quot;apple&quot;], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素array = [&quot;apple&quot;,&quot;boy&quot;];splices = array.splice(-3,1,&quot;cat&quot;);console.log(array); // [&quot;cat&quot;, &quot;boy&quot;]console.log(splices); // [&quot;apple&quot;], 可见即使-start超出数组长度,数组默认从首位开始删除array = [&quot;apple&quot;,&quot;boy&quot;];splices = array.splice(0,3,&quot;cat&quot;);console.log(array); // [&quot;cat&quot;]console.log(splices); // [&quot;apple&quot;, &quot;boy&quot;], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除123456789101112131415161718192021222324</code></pre><p>同上, splice一样受益于鸭式辨型, 比如:</p><pre><code>var o = &#123;0:&quot;apple&quot;,1:&quot;boy&quot;,length:2&#125;;var splices = Array.prototype.splice.call(o,1,1);console.log(o); // Object &#123;0: &quot;apple&quot;, length: 1&#125;, 可见对象o删除了一个属性,并且length-1console.log(splices); // [&quot;boy&quot;]1234</code></pre><p>注意：如果类数组对象没有length属性，splice将为该类数组对象添加length属性，并初始化为0。（此处忽略举例，如果需要请在评论里反馈）</p><p>如果需要删除数组中一个已存在的元素，可参考如下：</p><pre><code>var array = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];array.splice(array.indexOf(&#39;b&#39;),1);12</code></pre><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a><strong>unshift</strong></h5><p>unshift() 方法用于在数组开始处插入一些元素(就像是栈底插入)，并返回数组新的长度。</p><p>语法：<em>arr.unshift(element1, …, elementN)</em></p><pre><code>var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var length = array.unshift(&quot;yellow&quot;);console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]console.log(length); // 41234</code></pre><p>如果给unshift方法传入一个数组呢？</p><pre><code>var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var length = array.unshift([&quot;yellow&quot;]);console.log(array); // [[&quot;yellow&quot;], &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]console.log(length); // 4, 可见数组也能成功插入1234</code></pre><p>同上，unshift也受益于鸭式辨型，呈上栗子：</p><pre><code>var o = &#123;0:&quot;red&quot;, 1:&quot;green&quot;, 2:&quot;blue&quot;,length:3&#125;;var length = Array.prototype.unshift.call(o,&quot;gray&quot;);console.log(o); // Object &#123;0: &quot;gray&quot;, 1: &quot;red&quot;, 2: &quot;green&quot;, 3: &quot;blue&quot;, length: 4&#125;console.log(length); // 41234</code></pre><p>注意：如果类数组对象不指定length属性，则返回结果是这样的 <code>Object &#123;0: &quot;gray&quot;, 1: &quot;green&quot;, 2: &quot;blue&quot;, length: 1&#125;</code>，shift会认为数组长度为0，此时将从对象下标为0的位置开始插入，相应位置属性将被替换，此时初始化类数组对象的length属性为插入元素个数。</p><h5 id="copyWithin-ES6"><a href="#copyWithin-ES6" class="headerlink" title="copyWithin(ES6)"></a><strong>copyWithin(ES6)</strong></h5><p>copyWithin() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，用于数组内元素之间的替换，即替换元素和被替换元素均是数组内的元素。</p><p>语法：<em>arr.copyWithin(target, start[, end = this.length])</em></p><p>taget 指定被替换元素的索引，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。</p><p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。</p><p>注：目前只有Firefox（版本32及其以上版本）实现了该方法。</p><pre><code>var array = [1,2,3,4,5]; var array2 = array.copyWithin(0,3);console.log(array===array2,array2); // true [4, 5, 3, 4, 5]var array = [1,2,3,4,5]; console.log(array.copyWithin(0,3,4)); // [4, 2, 3, 4, 5]var array = [1,2,3,4,5]; console.log(array.copyWithin(0,-2,-1)); // [4, 2, 3, 4, 5]123456789</code></pre><p>同上，copyWithin一样受益于鸭式辨型，例如：</p><pre><code>var o = &#123;0:1, 1:2, 2:3, 3:4, 4:5,length:5&#125;var o2 = Array.prototype.copyWithin.call(o,0,3);console.log(o===o2,o2); // true Object &#123; 0=4,  1=5,  2=3,  更多...&#125;123</code></pre><p>如需在Firefox之外的浏览器使用copyWithin方法，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin#Polyfill">Polyfill</a>。</p><h5 id="fill-ES6"><a href="#fill-ES6" class="headerlink" title="fill(ES6)"></a><strong>fill(ES6)</strong></h5><p>fill() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。</p><p>语法：<em>arr.fill(value, start[, end = this.length])</em></p><p>value 指定被替换的值，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。</p><p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。</p><p>注：目前只有Firefox（版本31及其以上版本）实现了该方法。</p><pre><code>var array = [1,2,3,4,5];var array2 = array.fill(10,0,3);console.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10// 其他的举例请参考copyWithin1234</code></pre><p>同上，fill 一样受益于鸭式辨型，例如：</p><pre><code>var o = &#123;0:1, 1:2, 2:3, 3:4, 4:5,length:5&#125;var o2 = Array.prototype.fill.call(o,10,0,2);console.log(o===o2,o2); true Object &#123; 0=10,  1=10,  2=3,  更多...&#125;123</code></pre><p>如需在Firefox之外的浏览器使用fill方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Compatibility">Polyfill</a>。</p><h4 id="不会改变自身的方法-9个"><a href="#不会改变自身的方法-9个" class="headerlink" title="不会改变自身的方法(9个)"></a><strong>不会改变自身的方法(9个)</strong></h4><p>基于ES7，不会改变自身的方法一共有9个，分别为concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes。</p><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h5><p>concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回。</p><p>语法：<em>arr.concat(value1, value2, …, valueN)</em></p><pre><code>var array = [1, 2, 3];var array2 = array.concat(4,[5,6],[7,8,9]);console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(array); // [1, 2, 3], 可见原数组并未被修改1234</code></pre><p>若concat方法中不传入参数，那么将基于原数组<strong>浅复制</strong>生成一个一模一样的新数组（指向新的地址空间）。</p><pre><code>var array = [&#123;a: 1&#125;];var array3 = array.concat();console.log(array3); // [&#123;a: 1&#125;]console.log(array3 === array); // falseconsole.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用12345</code></pre><p>同上，concat 一样受益于鸭式辨型，但其效果可能达不到我们的期望，如下：</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;,length:3&#125;;var o2 = Array.prototype.concat.call(o,&#39;d&#39;,&#123;3:&#39;e&#39;,4:&#39;f&#39;,length:2&#125;,[&#39;g&#39;,&#39;h&#39;,&#39;i&#39;]);console.log(o2); // [&#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;, &#39;d&#39;, &#123;3:&#39;e&#39;, 4:&#39;f&#39;, length:2&#125;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;]123</code></pre><p>可见，类数组对象合并后返回的是依然是数组，并不是我们期望的对象。</p><h5 id="join"><a href="#join" class="headerlink" title="join"></a><strong>join</strong></h5><p>join() 方法将数组中的所有元素连接成一个字符串。</p><p>语法：<em>arr.join([separator = ‘,’])</em> separator可选，缺省默认为逗号。</p><pre><code>var array = [&#39;We&#39;, &#39;are&#39;, &#39;Chinese&#39;];console.log(array.join()); // &quot;We,are,Chinese&quot;console.log(array.join(&#39;+&#39;)); // &quot;We+are+Chinese&quot;console.log(array.join(&#39;&#39;)); // &quot;WeareChinese&quot;1234</code></pre><p>同上，join 一样受益于鸭式辨型，如下：</p><pre><code>var o = &#123;0:&quot;We&quot;, 1:&quot;are&quot;, 2:&quot;Chinese&quot;, length:3&#125;;console.log(Array.prototype.join.call(o,&#39;+&#39;)); // &quot;We+are+Chinese&quot;console.log(Array.prototype.join.call(&#39;abc&#39;)); // &quot;a,b,c&quot;123</code></pre><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a><strong>slice</strong></h5><p>slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。</p><p>语法：<em>arr.slice([start[, end]])</em></p><p>参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。</p><p>如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。</p><p>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。</p><pre><code>var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]console.log(array.slice(2,3)); // [&quot;three&quot;]123</code></pre><p><strong>浅复制</strong> 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。</p><pre><code>var array = [&#123;color:&quot;yellow&quot;&#125;, 2, 3];var array2 = array.slice(0,1);console.log(array2); // [&#123;color:&quot;yellow&quot;&#125;]array[0][&quot;color&quot;] = &quot;blue&quot;;console.log(array2); // [&#123;color:&quot;bule&quot;&#125;]12345</code></pre><p>由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。</p><p>同时，稍微利用下 slice 方法第一个参数为负数时的特性，我们可以非常方便的拿到数组的最后一项元素，如下：</p><pre><code>console.log([1,2,3].slice(-1));//[3]1</code></pre><p>同上，slice 一样受益于鸭式辨型。如下：</p><pre><code>var o = &#123;0:&#123;&quot;color&quot;:&quot;yellow&quot;&#125;, 1:2, 2:3, length:3&#125;;var o2 = Array.prototype.slice.call(o,0,1);console.log(o2); // [&#123;color:&quot;yellow&quot;&#125;] ,毫无违和感...123</code></pre><p>鉴于IE9以下版本对于该方法支持性并不是很好，如需更好的支持低版本IE浏览器，请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">polyfill</a>。</p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><strong>toString</strong></h5><p>toString() 方法返回数组的字符串形式，该字符串由数组中的每个元素的 <code>toString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。</p><p>语法： <em>arr.toString()</em></p><pre><code>var array = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;];var str = array.toString();console.log(str); // Jan,Feb,Mar,Apr123</code></pre><p>当数组直接和字符串作连接操作时，将会自动调用其toString() 方法。</p><pre><code>var str = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;] + &#39;,May&#39;;console.log(str); // &quot;Jan,Feb,Mar,Apr,May&quot;// 下面我们来试试鸭式辨型var o = &#123;0:&#39;Jan&#39;, 1:&#39;Feb&#39;, 2:&#39;Mar&#39;, length:3&#125;;var o2 = Array.prototype.toString.call(o);console.log(o2); // [object Object]console.log(o.toString()==o2); // true1234567</code></pre><p>可见，<code>Array.prototype.toString()</code>方法处理类数组对象时，跟类数组对象直接调用<code>Object.prototype.toString()</code>方法结果完全一致，说好的鸭式辨型呢？</p><p>根据ES5语义，toString() 方法是通用的，可被用于任何对象。如果对象有一个join() 方法，将会被调用，其返回值将被返回，没有则调用<code>Object.prototype.toString()</code>，为此，我们给o对象添加一个join方法。如下：</p><pre><code>var o = &#123;  0:&#39;Jan&#39;,   1:&#39;Feb&#39;,   2:&#39;Mar&#39;,   length:3,   join:function()&#123;    return Array.prototype.join.call(this);  &#125;&#125;;console.log(Array.prototype.toString.call(o)); // &quot;Jan,Feb,Mar&quot;12345678910</code></pre><h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a><strong>toLocaleString</strong></h5><p>toLocaleString() 类似toString()的变型，该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。</p><p>语法：<em>arr.toLocaleString()</em></p><p>数组中的元素将调用各自的 toLocaleString 方法：</p><ul><li><code>Object</code>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><code>Number</code>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString"><code>Number.prototype.toLocaleString()</code></a></li><li><code>Date</code>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString"><code>Date.prototype.toLocaleString()</code></a></li></ul><pre><code>var array= [&#123;name:&#39;zz&#39;&#125;, 123, &quot;abc&quot;, new Date()];var str = array.toLocaleString();console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23123</code></pre><p>其鸭式辨型的写法也同toString 保持一致，如下：</p><pre><code>var o = &#123;  0:123,   1:&#39;abc&#39;,   2:new Date(),   length:3,   join:function()&#123;    return Array.prototype.join.call(this);  &#125;&#125;;console.log(Array.prototype.toLocaleString.call(o)); // 123,abc,2016/1/5 下午1:16:5012345678910</code></pre><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><strong>indexOf</strong></h5><p>indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。</p><p>语法：<em>arr.indexOf(element, fromIndex=0)</em></p><p>element 为需要查找的元素。</p><p>fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex&lt;0 则整个数组都会被查找。</p><p>indexOf使用严格相等（即使用 === 去匹配数组中的元素）。</p><pre><code>var array = [&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;,&#39;123&#39;];console.log(array.indexOf(&#39;def&#39;)); // 1console.log(array.indexOf(&#39;def&#39;,-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1console.log(array.indexOf(&#39;def&#39;,-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1console.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串&#39;123&#39;12345</code></pre><p>得益于鸭式辨型，indexOf 可以处理类数组对象。如下：</p><pre><code>var o = &#123;0:&#39;abc&#39;, 1:&#39;def&#39;, 2:&#39;ghi&#39;, length:3&#125;;console.log(Array.prototype.indexOf.call(o,&#39;ghi&#39;,-4));//212</code></pre><p>然而该方法并不支持IE9以下版本，如需更好的支持低版本IE浏览器（IE6~8）， 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill">Polyfill</a>。</p><h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><strong>lastIndexOf</strong></h5><p>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1。并且它是indexOf的逆向查找，即从数组最后一个往前查找。</p><p>语法：<em>arr.lastIndexOf(element, fromIndex=length-1)</em></p><p>element 为需要查找的元素。</p><p>fromIndex 为开始查找的位置，缺省默认为数组长度length-1。如果超出数组长度，由于是逆向查找，则查找整个数组。如果为负值，则从数组的第 length + fromIndex项开始往数组开头查找，如果length + fromIndex&lt;0 则数组不会被查找。</p><p>同 indexOf 一样，lastIndexOf 也是严格匹配数组元素。</p><p>举例请参考 <code>indexOf</code> ，不再详述，兼容低版本IE浏览器（IE6~8），请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#Compatibility">Polyfill</a>。</p><h5 id="includes-ES7"><a href="#includes-ES7" class="headerlink" title="includes(ES7)"></a><strong>includes(ES7)</strong></h5><p>includes() 方法基于<strong>ECMAScript 2016（ES7）规范</strong>，它用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。</p><p>语法：<em>arr.includes(element, fromIndex=0)</em></p><p>element 为需要查找的元素。</p><p>fromIndex 表示从该索引位置开始查找 element，缺省为0，它是正向查找，即从索引处往数组末尾查找。</p><pre><code>var array = [-0, 1, 2];console.log(array.includes(+0)); // trueconsole.log(array.includes(1)); // trueconsole.log(array.includes(2,-4)); // true1234</code></pre><p>以上，includes似乎忽略了 <code>-0</code> 与 <code>+0</code> 的区别，这不是问题，因为JavaScript一直以来都是不区分 <code>-0</code> 和 <code>+0</code> 的。</p><p>你可能会问，既然有了indexOf方法，为什么又造一个includes方法，<code>arr.indexOf(x)&gt;-1</code>不就等于<code>arr.includes(x)</code>？看起来是的，几乎所有的时候它们都等同，唯一的区别就是includes能够发现NaN，而indexOf不能。</p><pre><code>var array = [NaN];console.log(array.includes(NaN)); // trueconsole.log(arra.indexOf(NaN)&gt;-1); // false123</code></pre><p>该方法同样受益于鸭式辨型。如下：</p><pre><code>var o = &#123;0:&#39;a&#39;, 1:&#39;b&#39;, 2:&#39;c&#39;, length:3&#125;;var bool = Array.prototype.includes.call(o, &#39;a&#39;);console.log(bool); // true123</code></pre><p>该方法只有在Chrome 47、opera 34、Safari 9版本及其更高版本中才被实现。如需支持其他浏览器，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill">Polyfill</a>。</p><h5 id="toSource-非标准"><a href="#toSource-非标准" class="headerlink" title="toSource(非标准)"></a><strong>toSource(非标准)</strong></h5><p>toSource() 方法是<strong>非标准的</strong>，该方法返回数组的源代码，目前只有 Firefox 实现了它。</p><p>语法：<em>arr.toSource()</em></p><pre><code>var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];console.log(array.toSource()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]// 测试鸭式辨型var o = &#123;0:&#39;a&#39;, 1:&#39;b&#39;, 2:&#39;c&#39;, length:3&#125;;console.log(Array.prototype.toSource.call(o)); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]12345</code></pre><h4 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个)"></a><strong>遍历方法(12个)</strong></h4><p>基于ES6，不会改变自身的方法一共有12个，分别为forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。</p><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h5><p>forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。</p><p>语法：<em>arr.forEach(fn, thisArg)</em></p><p>fn 表示在数组每一项上执行的函数，接受三个参数：</p><ul><li>value 当前正在被处理的元素的值</li><li>index 当前元素的数组索引</li><li>array 数组本身</li></ul><p>thisArg 可选，用来当做fn函数内的this对象。</p><p>forEach 将为数组中每一项执行一次 fn 函数，那些已删除，新增或者从未赋值的项将被跳过（但不包括值为 undefined 的项）。</p><p>遍历过程中，fn会被传入上述三个参数。</p><pre><code>var array = [1, 3, 5];var obj = &#123;name:&#39;cc&#39;&#125;;var sReturn = array.forEach(function(value, index, array)&#123;  array[index] = value * value;  console.log(this.name); // cc被打印了三次&#125;,obj);console.log(array); // [1, 9, 25], 可见原数组改变了console.log(sReturn); // undefined, 可见返回值为undefined12345678</code></pre><p>得益于鸭式辨型，虽然forEach不能直接遍历对象，但它可以通过call方式遍历类数组对象。如下：</p><pre><code>var o = &#123;0:1, 1:3, 2:5, length:3&#125;;Array.prototype.forEach.call(o,function(value, index, obj)&#123;  console.log(value,index,obj);  obj[index] = value * value;&#125;,o);// 1 0 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;// 3 1 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;// 5 2 Object &#123;0: 1, 1: 9, 2: 5, length: 3&#125;console.log(o); // Object &#123;0: 1, 1: 9, 2: 25, length: 3&#125;123456789</code></pre><p>参考前面的文章 <a href="http://louiszhai.github.io/2015/12/18/traverse/#forEach"><code>详解JS遍历</code></a> 中 forEach的讲解，我们知道，forEach无法直接退出循环，只能使用return 来达到for循环中continue的效果，并且forEach不能在低版本IE（6~8）中使用，兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#%E5%85%BC%E5%AE%B9%E6%97%A7%E7%8E%AF%E5%A2%83%EF%BC%88Polyfill%EF%BC%89">Polyfill</a>。</p><h5 id="every"><a href="#every" class="headerlink" title="every"></a><strong>every</strong></h5><p>every() 方法使用传入的函数测试所有元素，只要其中有一个函数返回值为 false，那么该方法的结果为 false；如果全部返回 true，那么该方法的结果才为 true。因此 every 方法存在如下规律：</p><ul><li><p>若需检测数组中存在元素大于100 （即 one &gt; 100），那么我们需要在传入的函数中构造 “false” 返回值 （即返回 item &lt;= 100），同时整个方法结果为 false 才表示数组存在元素满足条件；（简单理解为：若是单项判断，可用 one false ===&gt; false）</p></li><li><p>若需检测数组中是否所有元素都大于100 （即all &gt; 100）那么我们需要在传入的函数中构造 “true” 返回值 （即返回 item &gt; 100），同时整个方法结果为 true 才表示数组所有元素均满足条件。(简单理解为：若是全部判断，可用 all true ===&gt; true）</p></li></ul><p>语法同上述forEach，具体还可以参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#every"><code>详解JS遍历</code></a> 中every的讲解。</p><p>以下是鸭式辨型的写法：</p><pre><code>var o = &#123;0:10, 1:8, 2:25, length:3&#125;;var bool = Array.prototype.every.call(o,function(value, index, obj)&#123;  return value &gt;= 8;&#125;,o);console.log(bool); // true12345</code></pre><p>every 一样不能在低版本IE(6~8)中使用，兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#Compatibility">Polyfill</a>。</p><h5 id="some"><a href="#some" class="headerlink" title="some"></a><strong>some</strong></h5><p>some() 方法刚好同 every() 方法相反，some 测试数组元素时，只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false。some 方法存在如下规律：</p><ul><li><p>若需检测数组中存在元素大于100 (即 one &gt; 100)，那么我们需要在传入的函数中构造 “true” 返回值 (即返回 item &gt; 100)，同时整个方法结果为 true 才表示数组存在元素满足条件；（简单理解为：若是单项判断，可用 one true ===&gt; true）</p></li><li><p>若需检测数组中是否所有元素都大于100（即 all &gt; 100），那么我们需要在传入的函数中构造 “false” 返回值 （即返回 item &lt;= 100），同时整个方法结果为 false 才表示数组所有元素均满足条件。（简单理解为：若是全部判断，可用 all false ===&gt; false）</p></li></ul><p>你注意到没有，some方法与includes方法有着异曲同工之妙，他们都是探测数组中是否拥有满足条件的元素，一旦找到，便返回true。多观察和总结这种微妙的关联关系，能够帮助我们深入理解它们的原理。</p><p>some 的鸭式辨型写法可以参照every，同样它也不能在低版本IE（6~8）中使用，兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some#Compatibility">Polyfill</a>。</p><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h5><p>filter() 方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。</p><p>语法：<em>arr.filter(fn, thisArg)</em></p><pre><code>var array = [18, 9, 10, 35, 80];var array2 = array.filter(function(value, index, array)&#123;  return value &gt; 20;&#125;);console.log(array2); // [35, 80]12345</code></pre><p>filter一样支持鸭式辨型，具体请参考every方法鸭式辨型写法。其在低版本IE（6~8）的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Compatibility">Polyfill</a>。</p><h5 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h5><p>map() 方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。</p><p>语法：<em>arr.map(fn, thisArg)</em></p><p>参数介绍同 forEach 方法的参数介绍。</p><p>具体用法请参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#map"><code>详解JS遍历</code></a> 中 map 的讲解。</p><p>map 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法。</p><p>其在低版本IE（6~8）的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility">Polyfill</a>。</p><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong>reduce</strong></h5><p>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。</p><p>语法：<em>arr.reduce(fn, initialValue)</em></p><p>fn 表示在数组每一项上执行的函数，接受四个参数：</p><ul><li>previousValue 上一次调用回调返回的值，或者是提供的初始值</li><li>value 数组中当前被处理元素的值</li><li>index 当前元素在数组中的索引</li><li>array 数组自身</li></ul><p>initialValue 指定第一次调用 fn 的第一个参数。</p><p>当 fn 第一次执行时：</p><ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 将等于 initialValue，此时 item 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 previousVaule 等于数组中的第一个值，item 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么fn不会被执行，数组的唯一值将被返回。</li></ul><pre><code>var array = [1, 2, 3, 4];var s = array.reduce(function(previousValue, value, index, array)&#123;  return previousValue * value;&#125;,1);console.log(s); // 24// ES6写法更加简洁array.reduce((p, v) =&gt; p * v); // 241234567</code></pre><p>以上回调被调用4次，每次的参数和返回见下表：</p><table><thead><tr><th align="center">callback</th><th align="center">previousValue</th><th align="center">currentValue</th><th align="center">index</th><th align="center">array</th><th align="center">return value</th></tr></thead><tbody><tr><td align="center">第1次</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">[1,2,3,4]</td><td align="center">1</td></tr><tr><td align="center">第2次</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">[1,2,3,4]</td><td align="center">2</td></tr><tr><td align="center">第3次</td><td align="center">2</td><td align="center">3</td><td align="center">2</td><td align="center">[1,2,3,4]</td><td align="center">6</td></tr><tr><td align="center">第4次</td><td align="center">6</td><td align="center">4</td><td align="center">3</td><td align="center">[1,2,3,4]</td><td align="center">24</td></tr></tbody></table><p>reduce 一样支持鸭式辨型，具体请参考every方法鸭式辨型写法。</p><p>其在低版本IE（6~8）的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#%E5%85%BC%E5%AE%B9%E6%97%A7%E7%8E%AF%E5%A2%83%EF%BC%88Polyfill%EF%BC%89">Polyfill</a>。</p><h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a><strong>reduceRight</strong></h5><p>reduceRight() 方法接收一个方法作为累加器，数组中的每个值（从右至左）开始合并，最终为一个值。除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><p>其在低版本IE（6~8）的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#.E5.85.BC.E5.AE.B9.E6.80.A7.E6.97.A7.E7.8E.AF.E5.A2.83.EF.BC.88Polyfill.EF.BC.89">Polyfill</a>。</p><h5 id="entries-ES6"><a href="#entries-ES6" class="headerlink" title="entries(ES6)"></a><strong>entries(ES6)</strong></h5><p>entries() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</p><p>语法：<em>arr.entries()</em></p><pre><code>var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = array.entries();console.log(iterator.next().value); // [0, &quot;a&quot;]console.log(iterator.next().value); // [1, &quot;b&quot;]console.log(iterator.next().value); // [2, &quot;c&quot;]console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined123456</code></pre><p>很明显，entries 也受益于鸭式辨型，如下：</p><pre><code>var o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;;var iterator = Array.prototype.entries.call(o);console.log(iterator.next().value); // [0, &quot;a&quot;]console.log(iterator.next().value); // [1, &quot;b&quot;]console.log(iterator.next().value); // [2, &quot;c&quot;]12345</code></pre><p>由于该方法基于ES6，因此目前并不支持所有浏览器，以下是各浏览器支持版本：</p><table><thead><tr><th align="left">Browser</th><th align="left">Chrome</th><th align="left">Firefox (Gecko)</th><th align="left">Internet Explorer</th><th align="left">Opera</th><th align="left">Safari</th></tr></thead><tbody><tr><td align="left">Basic support</td><td align="left">38</td><td align="left"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28">28</a> (28)</td><td align="left">未实现</td><td align="left">25</td><td align="left">7.1</td></tr></tbody></table><h5 id="find-amp-findIndex-ES6"><a href="#find-amp-findIndex-ES6" class="headerlink" title="find&amp;findIndex(ES6)"></a><strong>find&amp;findIndex(ES6)</strong></h5><p>find() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回undefined。</p><p>findIndex() 方法也基于<strong>ECMAScript 2015（ES6）规范</strong>，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。</p><p>语法：<em>arr.find(fn, thisArg)<em>，</em>arr.findIndex(fn, thisArg)</em></p><p>我们发现它们的语法与forEach等十分相似，其实不光语法，find（或findIndex）在参数及其使用注意事项上，均与forEach一致。因此此处将略去 find（或findIndex）的参数介绍。下面我们来看个例子🌰 ：</p><pre><code>var array = [1, 3, 5, 7, 8, 9, 10];function f(value, index, array)&#123;  return value%2==0; // 返回偶数&#125;function f2(value, index, array)&#123;  return value &gt; 20; // 返回大于20的数&#125;console.log(array.find(f)); // 8console.log(array.find(f2)); // undefinedconsole.log(array.findIndex(f)); // 4console.log(array.findIndex(f2)); // -11234567891011</code></pre><p>由于其鸭式辨型写法也与forEach方法一致，故此处略去。</p><p>兼容性上我没有详测，可以知道的是，最新版的Chrome v47，以及Firefox的版本25均实现了它们。</p><h5 id="keys-ES6"><a href="#keys-ES6" class="headerlink" title="keys(ES6)"></a><strong>keys(ES6)</strong></h5><p>keys() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）</p><p>语法：<em>arr.keys()</em></p><pre><code>var array = [&quot;abc&quot;, &quot;xyz&quot;];var iterator = array.keys();console.log(iterator.next()); // Object &#123;value: 0, done: false&#125;console.log(iterator.next()); // Object &#123;value: 1, done: false&#125;console.log(iterator.next()); // Object &#123;value: undefined, done: false&#125;12345</code></pre><p>索引迭代器会包含那些没有对应元素的索引，如下：</p><pre><code>var array = [&quot;abc&quot;, , &quot;xyz&quot;];var sparseKeys = Object.keys(array);var denseKeys = [...array.keys()];console.log(sparseKeys); // [&quot;0&quot;, &quot;2&quot;]console.log(denseKeys);  // [0, 1, 2]12345</code></pre><p>其鸭式辨型写法请参考上述 entries 方法。</p><p>前面我们用Array.from生成一个从0到指定数字的新数组，利用keys也很容易实现。</p><pre><code>[...Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]12</code></pre><p>由于Array的特性，new Array 和 Array 对单个数字的处理相同，因此以上两种均可行。</p><p>keys基于ES6，并未完全支持，以下是各浏览器支持版本：</p><table><thead><tr><th align="center">Browser</th><th align="center">Chrome</th><th align="center">Firefox (Gecko)</th><th align="center">Internet Explorer</th><th align="center">Opera</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">Basic support</td><td align="center">38</td><td align="center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28">28</a> (28)</td><td align="center">未实现</td><td align="center">25</td><td align="center">7.1</td></tr></tbody></table><h5 id="values-ES6"><a href="#values-ES6" class="headerlink" title="values(ES6)"></a><strong>values(ES6)</strong></h5><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。</p><p>语法：<em>arr.values()</em></p><p>遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。</p><pre><code>var array = [&quot;abc&quot;, &quot;xyz&quot;];var iterator = array.values();console.log(iterator.next().value);//abcconsole.log(iterator.next().value);//xyz1234</code></pre><h5 id="Symbol-iterator-ES6"><a href="#Symbol-iterator-ES6" class="headerlink" title="Symbol.iterator(ES6)"></a><strong>Symbol.iterator(ES6)</strong></h5><p>该方法基于<strong>ECMAScript 2015（ES6）规范</strong>，同 values 方法功能相同。</p><p>语法：<em>arr<a href="">Symbol.iterator</a></em></p><pre><code>var array = [&quot;abc&quot;, &quot;xyz&quot;];var iterator = array[Symbol.iterator]();console.log(iterator.next().value); // abcconsole.log(iterator.next().value); // xyz1234</code></pre><p>其鸭式辨型写法请参考上述 entries 方法。</p><p>由于该方法基于ES6，并未完全支持，以下是各浏览器支持版本：</p><table><thead><tr><th align="center">Browser</th><th align="center">Chrome</th><th align="center">Firefox (Gecko)</th><th align="center">Internet Explorer</th><th align="center">Opera</th><th align="center">Safari</th></tr></thead><tbody><tr><td align="center">Basic support</td><td align="center">38</td><td align="center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/36">36</a> (36) <a href="http://louiszhai.github.io/2017/04/28/array/#respond">1</a></td><td align="center">未实现</td><td align="center">25</td><td align="center">未实现</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>以上，Array.prototype 的各方法基本介绍完毕，这些方法之间存在很多共性。比如：</p><ul><li>所有插入元素的方法, 比如 push、unshift，一律返回数组新的长度；</li><li>所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组；</li><li>部分遍历方法，比如 forEach、every、some、filter、map、find、findIndex，它们都包含<code>function(value,index,array)&#123;&#125;</code> 和 <code>thisArg</code> 这样两个形参。</li></ul><p>Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性。它们不止可以用来处理数组对象，还可以处理类数组对象。</p><p>例如 javascript 中一个纯天然的类数组对象字符串（String），像join方法（不改变当前对象自身）就完全适用，可惜的是 Array.prototype 中很多方法均会去试图修改当前对象的 length 属性，比如说 pop、push、shift, unshift 方法，操作 String 对象时，由于String对象的长度本身不可更改，这将导致抛出TypeError错误。</p><p>还记得么，Array.prototype本身就是一个数组，并且它的长度为0。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_part1</title>
      <link href="2020/09/25/leetcode-part1/"/>
      <url>2020/09/25/leetcode-part1/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p> 示例:</p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1][0，0，1，3，1，6] target = 0返回[0,1][-2,-31,-8,-10,-9,-7] target = -11返回[0，4]</code></pre><p>我的代码</p><pre><code>var twoSum = function(nums, target) &#123;    let res = []    for(let i = 0;i &lt; nums.length; i++) &#123;        // if(nums[i] &gt; target)        //     continue;        let logNum = target - nums[i]        for(let j = i + 1;j &lt; nums.length;j++) &#123;            if(logNum === nums[j])&#123;                res.push(i)                res.push(j)                return res            &#125;        &#125;    &#125;&#125;;</code></pre><p>执行用时：124 ms, 在所有 JavaScript 提交中击败了53.14%的用户 时间复杂度O(N^2^)</p><p>内存消耗：38.6 MB, 在所有 JavaScript 提交中击败了22.59%的用户</p><h2 id="hash表解法"><a href="#hash表解法" class="headerlink" title="hash表解法"></a>hash表解法</h2><p>利用数组减少查询时间<br>在暴力法中，内层循环查找差值很浪费时间，那么如何减少查询时间呢？利用数组就可以减少查询时间。<br>使用一层循环，每遍历到一个元素就计算该元素与 target之间的差值 dif，然后以 dif 为下标到数组temp中寻找，如果 temp[dif] 有值(即不是 undefined)，则返回两个元素在数组 nums 的下标，如果没有找到，则将当前元素存入数组 temp 中(下标: nums[i], Value: i) 。<br>时间复杂度：O(n)</p><pre><code>var twoSum = function(nums, target) &#123;    var temp = [];    for(var i=0;i&lt;nums.length;i++)&#123;        var dif = target - nums[i];        if(temp[dif] != undefined)&#123;            return [temp[dif],i];        &#125;        temp[nums[i]] = i;    &#125;&#125;;</code></pre><p>自我优化后代码</p><pre><code>var twoSum = function(nums, target) &#123;    let res = new Map();    let dif = 0;    let i = nums.length - 1;    while(i &gt;= 0) &#123;        dif = target - nums[i];        if(res.has(dif)) &#123;           return [res.get(dif),i]       &#125;       res.set(nums[i],i)       i--    &#125;&#125;;</code></pre><p>执行用时：72 ms, 在所有 JavaScript 提交中击败了95.34%的用户</p><p>内存消耗：39.4 MB, 在所有 JavaScript 提交中击败了8.00%的用户</p><h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><pre><code>输入: 123输出: 321</code></pre><p>我的代码</p><pre><code>var reverse = function(x) &#123;   let log = &#39;&#39;    let num = &#39;&#39;    function count(y) &#123;        if(y &lt; 0)&#123;            log = &#39;-&#39;            y = Math.abs(y)        &#125;        log = log + y % 10         num = (String)(y / 10)        if(parseInt(num) != 0) &#123;            count(parseInt(num))        &#125;        let logNum = parseInt(log)        return ((logNum &gt;= Math.pow(-2,31) &amp;&amp; logNum &lt;= (Math.pow(2,31) - 1)) ? logNum : 0)    &#125;    return count(x)&#125;;</code></pre><h2 id="别人的解法"><a href="#别人的解法" class="headerlink" title="别人的解法"></a>别人的解法</h2><ol><li>result * 10 + x % 10 取出末位 x % 10（负数结果还是负数，无需关心正负），拼接到 result 中</li><li>x / 10 去除末位，| 0 强制转换为32位有符号整数。</li><li>通过 | 0 取整，无论正负，只移除小数点部分（正数向下取整，负数向上取整）。</li><li>result | 0 超过32位的整数转换结果不等于自身，可用作溢出判断。</li></ol><pre><code>var reverse = function(x) &#123;    let result = 0;    while(x !== 0) &#123;        result = result * 10 + x % 10;        x = (x / 10) | 0;    &#125;    return (result | 0) === result ? result : 0;&#125;;</code></pre><pre><code>var reverse = function(x) &#123;    let ord = Math.abs(x);//去符号    let now = 0;    while(ord &gt; 0)&#123;        now = now * 10 + ord % 10;        ord = Math.floor(ord / 10);    &#125;    if(x &lt; 0)&#123;        return now &lt;= Math.pow(2,31) ? -now : 0;    &#125;else&#123;        return now &lt; Math.pow(2,31) ? now : 0;    &#125;&#125;;</code></pre><h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 :</p><pre><code>输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre><p>自己的代码</p><pre><code>var isPalindrome = function(x) &#123;    if(x &lt; 0)         return false    let n = 0    let log = x    while(x &gt; 0) &#123;        n = n * 10 + x % 10        x = Math.floor(x / 10)    &#125;    return (n === log) ? true : false&#125;;</code></pre><p>执行用时：208 ms, 在所有 JavaScript 提交中击败了92.57%的用户</p><p>内存消耗：46.4 MB, 在所有 JavaScript 提交中击败了54.13%的用户</p><h2 id="别人的解法-1"><a href="#别人的解法-1" class="headerlink" title="别人的解法"></a>别人的解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用除法和求余获得对应位置的数字，无字符串操作。</p><p><img src="https://s1.ax1x.com/2020/09/25/095JIO.png"></p><pre><code>var isPalindrome = function (x) &#123;    if (x &lt; 0) return false;    if (x &lt; 10) return true;    let n = 10 ** Math.floor(Math.log10(x));    while (n &gt; 1 &amp;&amp; x &gt; 0) &#123;        if (Math.floor(x / n) !== x % 10) return false;        x = Math.floor((x % n) / 10);        n /= 100;    &#125;    return true;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据解构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise</title>
      <link href="2020/09/25/promise/"/>
      <url>2020/09/25/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>概念上说，Promise是异步编程的一种解决方案。</p><p>从语法上说，Promise是一个对象，可以从他获取异步操作的消息。</p><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>Promise对象有三种状态：</p><ol><li><p>pending （进行中）</p></li><li><p>fulfilled（已成功）</p></li><li><p>rejected （已失败）</p></li></ol><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>Promise接受一个函数作为参数，这个函数的两个参数分别是resolve和reject。</p><ol><li><p>resolve -&gt; 将Promise对象的状态从pending变为resolved,并且将异步操作成功返回的结果作为参数传递出去</p></li><li><p>reject -&gt; 将Promise对象的状态从pending变为 rejected，并且将异步操作返回的错误作为参数传递出去</p></li></ol><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>　　Promise对象有两个特点：</p><p>　　1. 对象的状态不受外界印象。Promise对象的状态只有异步操作的结果可以决定</p><p>　　2. 对象的状态改变就不会再变。Promise对象有两种状态改变,一是从pending到resolved，二是从pending到rejected。这两种状态只要发生一种，就会一直保持这个结果。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>　　1. Promise一旦执行，无法取消。</p><p>　　2. Promise如果不设置回调函数，其内部抛出的错误不会反应到外部</p><p>　　3. pending状态，无法得知目前进展到哪一个阶段</p><h1 id="promise方法"><a href="#promise方法" class="headerlink" title="promise方法"></a>promise方法</h1><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then方法接收两个函数作为参数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数。两个函数只有一个会被调用。</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    resolve() // 结果输出：then方法的第一个参数    reject() // 当处于resloved状态时没有输出结果，两个方法不能同时生效 结果输出：then方法的第二个参数&#125;)p.then(() =&gt; &#123;    console.log(&quot;then方法的第一个参数&quot;)&#125;,() =&gt; &#123;    console.log(&quot;then方法的第二个参数&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;catch方法&quot;)&#125;)</code></pre><p>then方法返回一个新的Promise实例（不是之前那个），故此可以写成链式调用，then方法之后再调用另一个then方法。这样的写法可以指定一组按照次序调用的回调函数，因为如果前面一个回调函数返回的依然是一个promise对象，那么下一个回调函数就会等待这个Promise的状态结果才调用。</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        console.log(&quot;Promise ----- p&quot;)        resolve()    &#125;,1000)&#125;)let p1 = new Promise((resolve,reject) =&gt;&#123;    console.log(&quot;Promise ----- p1&quot;)    resolve(p)&#125;)p1.then(res =&gt; &#123;    console.log(&quot;then方法的第一个参数&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;catch方法&quot;)&#125;)返回结果的输出顺序：　　Promise ----- p1　　（两次输出之间间隔1秒）　　Promise ----- p　　then方法的第一个参数</code></pre><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    resolve()&#125;)p.then(() =&gt; &#123;    console.log(&quot;第一个then方法&quot;)&#125;).then(() =&gt; &#123;    console.log(&quot;第二个then方法&quot;)&#125;).then(() =&gt; &#123;    console.log(&quot;第三个then方法&quot;)&#125;).then(() =&gt; &#123;    console.log(&quot;第四个then方法&quot;)&#125;).then(() =&gt; &#123;    console.log(&quot;第五个then方法&quot;)&#125;)输出结果：　　第一个then方法　　第二个then方法　　第三个then方法　　第四个then方法　　第五个then方法</code></pre><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a><strong>catch方法</strong></h2><p>发生错误时的回调函数。Promise对象的错误具有向后传递的性质，前面的错误（包括then方法中的错误或者前面一个catch中的错误）总是会被下一 个catch捕获（捕获前面没有被捕获的错误，包括then的回调函数中抛出的错误）。</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    reject()&#125;)p.then(() =&gt; &#123;    console.log(&quot;then方法的第一个参数&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;catch方法&quot;)&#125;)结果输出:　　catch方法</code></pre><p>catch捕捉then方法中的错误</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    resolve()&#125;)p.then(() =&gt; &#123;    console.log(&quot;then方法的第一个参数&quot;)    throw new Error(&quot;then 错误&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;catch方法&quot;)&#125;)输出结果：　　　then方法的第一个参数　　catch方法</code></pre><p>catch向后传递的特性</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    reject()&#125;)p.then(() =&gt; &#123;    console.log(&quot;then方法的第一个参数&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;第一个catch方法&quot;)    throw new Error(&quot;catch错误&quot;)&#125;).then(() =&gt; &#123;    console.log(&quot;第二个then方法&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;第二个catch&quot;)&#125;)输出结果：　　第一个catch方法　　第二个catch</code></pre><p><strong>finally方法</strong></p><p>不管Promise对象的状态是什么都会执行的操作。finally方法的回调函数不接受任何参数，则没有办法知道前端Promise的具体状态，换句话说finally不依赖于Promise的执行结果</p><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;    resolve()&#125;)p.then(() =&gt; &#123;    console.log(&quot;第一个then方法&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;第一个catch方法&quot;)&#125;).finally(() =&gt; &#123;    console.log(&quot;finally&quot;)&#125;)输出结果：　　　　第一个then方法　　finally</code></pre><pre><code>let p  = new Promise((resolve,reject) =&gt; &#123;   reject()&#125;)p.then(() =&gt; &#123;    console.log(&quot;第一个then方法&quot;)&#125;).catch(() =&gt; &#123;    console.log(&quot;第一个catch方法&quot;)&#125;).finally(() =&gt; &#123;    console.log(&quot;finally&quot;)&#125;)输出结果：　　　　第一个catch方法　　finally</code></pre><p><strong>all方法</strong></p><p>all方法用于将多个Promise实例包装成一个新的Promise实例。新的Promise实例的状态由组成它的Promise实例的状态共同决定（个人感觉有点类似于&amp;&amp;运算符）。</p><p>1&gt; 多个Promise实例的状态都变成已完成（resolved）状态，新的Promise实例的状态才会变成已完成状态，并且将多个Promise实例的返回值组成一个数组传递给新的Promise的回调函数</p><p>2&gt; 多个Promise实例中，只要有一个实例的状态变成rejected，新的实例的状态就会变成rejecte，并且将第一个状态为rejected的实例的返回值传递给新的Promise实例的回调函数。</p><pre><code> let p1  = new Promise((resolve,reject) =&gt; &#123;     resolve(&quot;p1&quot;)  &#125;) let p2  = new Promise((resolve,reject) =&gt; &#123;      resolve(&quot;p2&quot;)  &#125;)  let p3  = new Promise((resolve,reject) =&gt; &#123;      resolve(&quot;p3&quot;) &#125;) let p  = Promise.all([p1,p2,p3]) p.then(res =&gt; &#123;     console.log(&#39;返回结果res --&gt;&#39;,res) &#125;) .catch((error) =&gt; &#123;     console.log(&#39;返回错误error --&gt;&#39;,error) &#125;) 输出结果：　　返回结果res --&gt; (3) [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</code></pre><pre><code>let p1  = new Promise((resolve,reject) =&gt; &#123;     resolve(&quot;p1&quot;)&#125;)let p2  = new Promise((resolve,reject) =&gt; &#123;       reject(&quot;p2&quot;)&#125;)let p3  = new Promise((resolve,reject) =&gt; &#123;    resolve(&quot;p3&quot;)&#125;) let p  = Promise.all([p1,p2,p3])p.then(res =&gt; &#123;     console.log(&#39;返回结果res --&gt;&#39;,res)&#125;).catch((error) =&gt; &#123;     console.log(&#39;返回错误error --&gt;&#39;,error)&#125;)输出结果：　　返回错误error --&gt; p2</code></pre><p><strong>race方法</strong></p><p>跟all方法相同，将多个Promise实例包装成一个新的Promise实例，只不过和all方法不同的是，race是哪个Promise先返回结果就取哪个Promise的结果，不会等待全部的Promise实例执行完。</p><p>all方法返回的结果和参数中数组的有关系，但是race方法的返回结果和Promise实例的执行顺序有关。</p><pre><code>let p1  = new Promise((resolve,reject) =&gt; &#123;    resolve(&quot;p1&quot;)&#125;)let p2  = new Promise((resolve,reject) =&gt; &#123;    resolve(&quot;p2&quot;)&#125;)let p3  = new Promise((resolve,reject) =&gt; &#123;    resolve(&quot;p3&quot;)&#125;)let p  = Promise.race([p1,p2,p3])p.then(res =&gt; &#123;    console.log(&#39;返回结果res --&gt;&#39;,res)&#125;).catch((error) =&gt; &#123;    console.log(&#39;返回错误error --&gt;&#39;,error)&#125;)输出结果：　　返回结果res --&gt; p1</code></pre><pre><code>let p1  = new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&quot;p1&quot;)    &#125;,1000)&#125;)let p2  = new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&quot;p2&quot;)    &#125;,1500)&#125;)let p3  = new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        reject(&quot;p3&quot;)    &#125;,500)&#125;)let p  = Promise.race([p1,p2,p3])p.then(res =&gt; &#123;    console.log(&#39;返回结果res --&gt;&#39;,res)&#125;).catch((error) =&gt; &#123;    console.log(&#39;返回错误error --&gt;&#39;,error)&#125;)输出结果：　　返回错误error --&gt; p3</code></pre><p>小记：</p><p><strong>catch和then方法的第二个参数的区别：</strong></p><p>我们知道，then方法的是第二个参数和catch都是Promise状态变为rejected时执行的回调函数，但是我们一般不用then方法的第二个参数而总是使用catch方法，这是因为catch方法可以捕获到then方法中的错误，而then方法的第二个参数是捕捉不到的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目中遇到的问题</title>
      <link href="2020/09/24/xiang-mu-zhong-yu-dao-de-wen-ti/"/>
      <url>2020/09/24/xiang-mu-zhong-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h1><ol><li>向后端请求数据要查看network的headers中的url是否与API的url一致</li><li>请求的数据(data)要传递一个对象</li><li>将修改的文件点选加号提交到暂存区，QUEST-33  提交的信息，点选左下角的上传，提交代码</li></ol><h1 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h1><ol><li>js使用map提升效率</li></ol><pre><code>声明 var map = new Map();设值map.set(&quot;key&quot;,&quot;value&quot;);取值map.get(&quot;key&quot;);判断key是否存在map.has(&quot;key&quot;);删除keymap.delete(&quot;key&quot;);</code></pre><ol start="2"><li>强制类型转换</li></ol><pre><code>string提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数Boolean(value)——把给定的值转换成Boolean型；Number(value)——把给定的值转换成数字（可以是整数或浮点数）；String(value)——把给定的值转换成字符串。</code></pre><ol start="3"><li>2 ** 5 结果32 10**3 结果1000</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="2020/09/24/dan-dian-deng-lu/"/>
      <url>2020/09/24/dan-dian-deng-lu/</url>
      
        <content type="html"><![CDATA[<p>在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。</p><p>但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员</p><p>来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。</p><p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong></p><p><img src="https://s1.ax1x.com/2020/09/24/0SEQC4.png"></p><p>如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。</p><h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><p>在说单点登录（SSO）的技术实现之前，我们先说一说普通的登录认证机制。</p><p><img src="https://s1.ax1x.com/2020/09/24/0SEnET.png"></p><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a>同域下的单点登录</h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li><li><img src="https://s1.ax1x.com/2020/09/24/0SEK5F.png"></li></ul><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p><h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a>不同域下的单点登录</h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。</p><p>具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p><p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li><li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li><li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript+vue</title>
      <link href="2020/09/23/typescript-vue-zhi-shi-dian/"/>
      <url>2020/09/23/typescript-vue-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Vue<span class="token punctuation">,</span> Prop<span class="token punctuation">,</span> Emit<span class="token punctuation">,</span> Component<span class="token punctuation">,</span> Watch<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">'vue-property-decorator'</span><span class="token punctuation">;</span></code></pre><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><blockquote><p>2.1.0 新增</p></blockquote><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p>例如：</p><pre><code>&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</code></pre><h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><p>父组件 $emitFa.vue</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>$emit子组件调用父组件的方法并传递数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>父组件数据：<span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#123;">&amp;#123;</span>msg<span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>emit-ch</span> <span class="token attr-name">@updateInfo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateInfo<span class="token punctuation">"</span></span> <span class="token attr-name">:sendData</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>emit-ch</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> emitCh <span class="token keyword">from</span> <span class="token string">'./$emitCh'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">'emitFa'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> emitCh <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      msg<span class="token punctuation">:</span> <span class="token string">'北京'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    updateInfo <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 点击子组件按钮时触发事件</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> data<span class="token punctuation">.</span>city <span class="token comment" spellcheck="true">// 改变了父组件的值</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>子组件 $emitCh.vue</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>train-city<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>父组件传给子组件的数据：<span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#123;">&amp;#123;</span>sendData<span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>select()<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>点击子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">'emitCh'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 相当于一个全局 ID，可以不写，写了可以提供更好的调试信息</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sendData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 用来接收父组件传给子组件的数据</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    select <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        city<span class="token punctuation">:</span> <span class="token string">'杭州'</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'updateInfo'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// select事件触发后，自动触发updateInfo事件</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h1 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h1><p>子组件：</p><pre><code>alertInfo() &#123;      console.log(&#39;子组件的输出方法&#39;)    &#125;</code></pre><p>父组件</p><p>index.html</p><pre><code>    &lt;prj-search-tool        :searchToolItems = &#39;searchToolItems&#39;        @getTableData = &#39;onSubmit111&#39;        ref = &#39;myChild&#39;    &gt;</code></pre><p>vue.html</p><pre><code>childFun() &#123;        (this.$refs[&quot;myChild&quot;] as prjSearchTool).alertInfo();    &#125;</code></pre><h1 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h1><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed :"></a><strong>计算属性computed :</strong></h2><ol><li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li><li><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p></li><li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p></li><li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><p><img src="https://s1.ax1x.com/2020/09/18/whd4FH.png"></p></li></ol><h2 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h2><ol><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p>watch支持异步；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p></li></ol><p>　　immediate：组件加载立即触发回调函数执行，</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p><p><img src="https://s1.ax1x.com/2020/09/18/whwlnK.png"></p><pre><code>input: string = &#39;&#39;    @Watch(&#39;input&#39;)    alertInfo() &#123;        if(this.input === &#39;&#39;)            alert(1)    &#125;</code></pre><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>子组件使用具名插槽</p><pre><code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</code></pre><p>父组件调用子组件时，定义插槽中内容</p><pre><code> &lt;template v-slot:header&gt;        &lt;p&gt;我是header&lt;/p&gt;      &lt;/template&gt;    &lt;template v-slot:footer&gt;        &lt;p&gt;我是footer&lt;/p&gt;      &lt;/template&gt;</code></pre><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p> 相较于常规的赋值方式,解构赋值最主要的是’解构’两个字,在赋值的过程中要清晰的知道等号右边的结构.</p><p> 先简单地看一下原来的赋值方式.</p><pre><code>var a=[1,2]　　</code></pre><p>分析一下这句代码的几个点:</p><p>(1)变量申明和赋值</p><pre><code>var a;a=[1,2]//你可以理解这两个操作是分开的,虽然是一句代码.声明变量都会出现变量名的提升(也就是是声明变量的这句代码会被提升到生效作用域的最前面),区别在于&#39;var&#39;声明的是全局变量,而&#39;let const&#39;声明的是块级作用域变量.</code></pre><p> (2)结构对应</p><pre><code>var a;a=[1,2];a=12;   a=&#123;name:&#39;小明&#39;,age:18&#125;</code></pre><p> 解构赋值</p><p>结合上面的的例子,假如我现在只想要{name:’小明’,age:18}这个对象中的’name’属性,原来的做法</p><pre><code>var a=&#123;name:&#39;小明&#39;,age:18&#125;console.log(a.name)</code></pre><p>   就需要通过点语法去获取,实际开发中,我们的数据很多时候是嵌套很多层的,所以就会出现类似’a.b.c.d’这类代码.看着让人头晕,而解构赋值就是解决这个问题的方案之一</p><p>基本用法</p><p><strong>(1)声明和赋值</strong></p><p>  <strong>数组</strong></p><pre><code>let [a] = [1];</code></pre><p>  对象</p><pre><code>let &#123;name&#125; = &#123;name:&#39;小明&#39;,age:18&#125;</code></pre><p>　{变量名}:变量名必须是对象中的属性名　</p><p><strong>(2)结构对应(重难点)</strong>　</p><p> 数组(要位不要名)　</p><p> 对象(要名不要位)</p><p> 完全解构　</p><p>​    <strong>数组:</strong></p><p>​     <strong>a:按顺序</strong></p><pre><code>let [a, b, c] = [1, 2, 3];console.log(a,b,c)//1,2,3这样赋值的语义是我知道右边是一个有三个元素的数字,所以我声明了一个数组,三个元素分别是a,b,c和右边的三个元素对应.所以a=1,b=2,c=3 </code></pre><p> 　 <strong>b:打乱顺序</strong></p><pre><code>let [a, c, b] = [1, 2, 3];console.log(a,b,c)//1,3,2因为三个变量的位置变了,所以其对应的元素(值)也就变量　　</code></pre><p>　<strong>对象:</strong></p><p>​    <strong>a:按顺序</strong></p><pre><code>let &#123;name,age&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,age)//小明,18</code></pre><p>  　<strong>b:打乱顺序</strong>　　</p><pre><code>let &#123;age,name&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,age)//小明,18</code></pre><p>　虽然变量的声明前后顺序变了,但是对象中的值没变,它最终还是根据属性名去找值,所以结果没变</p><p><strong>c:不存在的属性名</strong></p><pre><code>let &#123;name,sex&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(name,sex)//小明,undefined</code></pre><p>嵌套解构</p><p>  <strong>数组</strong>:</p><pre><code>let [a, [b,c], d] = [1, [2, 3], 4];console.log(a,b,c,d)//1,2,3,4//反正结构和位置一一对应就行了.</code></pre><p> <strong>对象</strong></p><pre><code>const obj=&#123;    man:&#123;      student:&#123;           name:&#39;小明&#39;,           age:18        &#125;   &#125;&#125;let &#123;man:&#123;student&#125;&#125; = obj //obj里面有个man,然后里面有个student,注意这一行代码里变量就只有一个student,并没有manconsole.log(man,student) // undefined,&#123;name:&#39;小明&#39;,age:18&#125;let &#123;man:&#123;student:&#123;name&#125;&#125;&#125; = obj //同理,逐层拿到最后的name值,而且也只有name这一个属性console.log(name) //小明//如何同时拿到嵌套的每层的数据let &#123;man,man:&#123;studengt&#125;,man:&#123;student:&#123;name&#125;&#125;&#125; = objconsole.log(man,student,name) //&#123;student:&#123;name:&#39;小明&#39;,age:18&#125;&#125;,&#123;name:&#39;小明&#39;,age:18&#125;,18</code></pre><p>不完全解构</p><pre><code>let [a, b] = [1, 2, 3];console.log(a,b,c)//1,2//这里变量只有两个,但是数组中元素有三个.这里还是根据位置对应原理就行.a表示数组中的第一个元素,b表示第2个.而第三个元素我不要.let [a, [b], d] = [1, [2, 3], 4];console.log(a,b,d)//1,2,4//嵌套解构同样也可以不完全解构,根据实际需要,需要哪个就解构赋值哪个let [, , c] = [1, 2, 3];console.log(c)//3//注意这里是完全解构,只不过前两个元素我虽然解构了,但是我不要.因为位置对应的关系,所以必须有两个占位的,才能拿到第三个.//放在这里是为了方便理解为啥前面两个明明不要还得写两个&#39;,&#39;</code></pre><p> 超量赋值(自己瞎编的词)　　</p><pre><code>let [a,b,c,d] = [1,2,3]onsole.log(a,b,c,d)//1,2,3,undefined//因为前三个元素都能对应找到,而第四个找不到,但是已经声明了,没有值.//对象同理,如果出现了对象中没有的属性就会得到undefined</code></pre><p><strong>(3)重命名(先取再重命名)</strong></p><p>  数组:我们上面说过,数组解构的时候只要注意位置对应就行了,名称啥的无所谓,你喜欢叫什么变量名就什么变量名</p><p>  对象:对象解构的时候是要属性名对应才能取到值.但是没有说取到值之后不能重命名啊.一定要取到值之后在命名　　</p><pre><code>let &#123;name:myName,age&#125; =&#123;name:&#39;小明&#39;,age:18&#125;//这里name:myName的意思是:取到name属性值,冒号后面的变量名没有花括号,意思是把我取到的值交给冒号后面的变量名,即&#39;myName&#39;.相当于把name变量重命名为myName//而student:&#123;name&#125;,同样是&#39;属性名:&#39;意思一样,取里面对应的属性,冒号后面还有花括号,所以再解构,取student里面的name属性console.log(name,myName,age)//undefined,小明,18</code></pre><p>　<strong>(4)默认值(先取再默认)</strong></p><p>​    数组</p><pre><code>let [a=0, b=0,c=10] = [1, 2];console.log(a,b,c) //1,2,10//这里a,b,c在左边都先给了个默认值,但是这里是超量解构,a和b都成功取到值,但是c没取到,所以最终是默认值10,如果没有默认值就是undefined</code></pre><p>对象</p><pre><code>let &#123;name:sex=&#39;男&#39;&#125; =&#123;name:&#39;小明&#39;,age:18&#125;console.log(sex)  //小明let &#123;name:&#123;sex=&#39;男&#39;&#125;&#125; = &#123;name:&#39;小明&#39;,age:18&#125;console.log(sex)  //男//这里刚好通过这两个例子区分一下重命名和嵌套</code></pre><p>  <strong>(5)字符串解构</strong></p><p>  字符串的解构可以理解为一维数组的解构,这在处理字符串的时候特别方便.</p><pre><code>let [a,b,c] =&#39;123&#39;console.log(a,b,c,typeof c)  //1,2,3,string   解构出来的是字符类型的数据　</code></pre><p>　长度</p><pre><code>let &#123;length:s&#125; =&#39;123&#39;console.log(s,typeof s) //3,number //同理,数组也有长度let &#123;length:s&#125; = [1,2,3]console,log(s,typeof s) //3,number</code></pre><p><strong>(6)函数参数自动解构</strong></p><pre><code>function look([x,y])&#123;console.log(x,y)&#125;look([1,2]) //1,2</code></pre><p>参数默认值陷阱单独再写一篇</p><p>  <strong>(7)先声明再赋值(少用)</strong></p><p>  <strong>数组</strong></p><pre><code>let a;let b;[a,b]=[1,2]console.log(a,b) //1,2</code></pre><p><strong>对象</strong></p><pre><code>let x;&#123;x&#125;=&#123;x:1,y:1&#125; //报错 主要还是大括号的原因,js在行首遇到&#123;&#125;会把它当做代码块执行,所以会报错.(&#123;x&#125;=&#123;x:1,y:1&#125;) //这样可以解决问题,但是尽量别引入(),问题会变得复杂</code></pre><p>到这里为止,解构赋值的日常使用没问题了,它带来了不少方便,但也会产生一些新bug,比如:let {data} =res 的写法,假如res里面并没有data属性,那就会undefined,所以还是得明确等号右边的解构.　</p><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>当刷新页面（这里的刷新页面指的是 –&gt; F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage页面关闭后就清除掉了，localstorage不会。 </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="2020/09/22/docker/"/>
      <url>2020/09/22/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p> 镜像看作类，把容器看作类实例化后的对象 </p><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h3><p>款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做！</p><p>现在：开发打包部署上线，一套流程做完！</p><p> java – jar（环境） — 打包项目带上环境（镜像） —- ( Docker仓库：商店）—-下载到为我们发布的镜像 —- 直接运行即可！ </p><h3 id="Docker解决方案"><a href="#Docker解决方案" class="headerlink" title="Docker解决方案"></a>Docker解决方案</h3><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) — 原来都是交叉的！</p><p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p>水果 生化武器</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><h3 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p><p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>他们将自己的技术（容器化技术）命名就是 Docker</p><p>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>2013年，Docker开源！</p><p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p><p>2014年4月9日，Docker1.0发布！</p><p>docker为什么这么火？十分的轻巧！</p><p>在容器技术出来之前，我们都是使用虚拟机技术！</p><p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p><p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><p>vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟<br>docker : 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</p><h3 id="聊聊Docker"><a href="#聊聊Docker" class="headerlink" title="聊聊Docker"></a>聊聊Docker</h3><p>Docker基于Go语言开发的！开源项目！</p><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><p>之前的虚拟机技术！</p><p><img src="G:\xmind&md\imgs\1591688800800.png" alt="1591688800800"></p><h4 id="虚拟机技术缺点："><a href="#虚拟机技术缺点：" class="headerlink" title="虚拟机技术缺点："></a>虚拟机技术缺点：</h4><p>1、 资源占用十分多</p><p>2、 冗余步骤多</p><p>3、 启动很慢！</p><h4 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a><strong>容器化技术</strong></h4><p> <strong>容器化技术不是模拟一个完整的操作系统</strong> </p><p><img src="G:\xmind&md\imgs\1591689239886.png" alt="1591689239886"></p><h4 id="比较Docker和虚拟机技术的不同："><a href="#比较Docker和虚拟机技术的不同：" class="headerlink" title="比较Docker和虚拟机技术的不同："></a>比较Docker和虚拟机技术的不同：</h4><p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件<br>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了<br>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p><h3 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h3><h4 id="1-应用更快速的交付和部署"><a href="#1-应用更快速的交付和部署" class="headerlink" title="1.应用更快速的交付和部署"></a>1.应用更快速的交付和部署</h4><p>传统：一对帮助文档，安装程序。</p><p>Docker：打包镜像发布测试一键运行。</p><h4 id="2-更便捷的升级和扩缩容"><a href="#2-更便捷的升级和扩缩容" class="headerlink" title="2.更便捷的升级和扩缩容"></a>2.更便捷的升级和扩缩容</h4><p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p><h4 id="3-更简单的系统运维"><a href="#3-更简单的系统运维" class="headerlink" title="3.更简单的系统运维"></a>3.更简单的系统运维</h4><p>在容器化之后，我们的开发，测试环境都是高度一致的</p><h4 id="4-更高效的计算资源利用"><a href="#4-更高效的计算资源利用" class="headerlink" title="4.更高效的计算资源利用"></a>4.更高效的计算资源利用</h4><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h3><p><img src="G:\xmind&md\imgs\1591689686866.png" alt="1591689686866"></p><p>**镜像(image):**类似一个模板，可以通过一个镜像来创建容器服务，tomcat==&gt;run==&gt;tomcat01容器(提供服务的)，可以通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。类似java中的类(镜像)和对象(容器)</p><p>**容器(contain):**可以独立运行一个或者一组应用，通过镜像创建。</p><p>基本命令：启动，停止，删除。</p><p>**仓库(repository):**就是存放镜像的地方。</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p> <em>1.卸载旧版本</em> </p><pre><code>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine  </code></pre><p> <em>2.需要的安装包</em> </p><pre><code>yum install -y yum-utils</code></pre><p> <em>3.设置镜像的仓库</em> </p><pre><code>yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的，不推荐#推荐使用阿里云的，非常快yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#更新yum软件包索引yum makecache fast</code></pre><p> <em>4.安装docker相关的 docker-ce 社区版 而ee是企业版</em> </p><pre><code>yum install docker-ce docker-ce-cli containerd.io</code></pre><p> <em>5. 启动docker</em> </p><pre><code>systemctl start docker</code></pre><p> <em>6. 使用docker version查看是否按照成功</em> </p><pre><code> docker version</code></pre><p> <em>7. 测试</em> </p><p>设置国内下载源</p><pre><code># vi /etc/docker/daemon.json&#123;    &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;systemctl restart docker.service</code></pre><pre><code>docker run hello-worlddocker exec -it 775c7c9ee1e1 /bin/bash  </code></pre><p> <em>8.查看一下下载的镜像</em>       </p><pre><code>docker images</code></pre><h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><pre><code>#1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io#2. 删除资源rm -rf /var/lib/docker# /var/lib/docker docker的默认</code></pre><h3 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h3><p><img src="G:\xmind&md\imgs\1591691509601.png" alt="1591691509601"></p><p> docker run 流程图 </p><p><img src="G:\xmind&md\imgs\1591691537760.png" alt="1591691537760"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="Docker是怎么工作的？"><a href="#Docker是怎么工作的？" class="headerlink" title="Docker是怎么工作的？"></a>Docker是怎么工作的？</h4><ul><li>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</li><li>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</li><li><img src="G:\xmind&md\imgs\1591691653610.png" alt="1591691653610"></li></ul><h4 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h4><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>docker利用的是宿主机的内核,而不需要Guest OS。</p><p>GuestOS： VM（虚拟机）里的的系统（OS）;<br>HostOS：物理机里的系统（OS）；</p><p><img src="G:\xmind&md\imgs\1591691833753.png" alt="1591691833753"></p><p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><pre><code>docker images 查看所有镜像</code></pre><p><img src="G:\xmind&md\imgs\1591692390070.png" alt="1591692390070"></p><pre><code>docker search mysql 搜索镜像docker pull mysql   下载镜像</code></pre><p><img src="G:\xmind&md\imgs\1591692754240.png" alt="1591692754240"></p><p><img src="G:\xmind&md\imgs\1591692801844.png" alt="1591692801844"></p><pre><code>docker rmi 删除镜像docker rmi -f $(docker images -aq) 删除全部镜像</code></pre><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><pre><code>docker pull centos</code></pre><h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><pre><code>docker run [可选参数] imagedocker run -it 470671670cac /bin/bashexit 退出容器Ctrl + P + Q 容器不停止退出docker ps 查看正在运行的容器docker rm 容器id 删除容器，不能删除正在运行的容器</code></pre><p><img src="G:\xmind&md\imgs\1591693427313.png" alt="1591693427313"></p><p><img src="G:\xmind&md\imgs\1591694744515.png" alt="1591694744515"></p><h3 id="常用的其他命令"><a href="#常用的其他命令" class="headerlink" title="常用的其他命令"></a>常用的其他命令</h3><pre><code>docker run -d centos 后台启动问题 docker ps ，发现centos停止了docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止</code></pre><p><img src="G:\xmind&md\imgs\1591695363396.png" alt="1591695363396"></p><p><img src="G:\xmind&md\imgs\1591695466426.png" alt="1591695466426"></p><h4 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h4><pre><code>docker inspect 容器id</code></pre><h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><pre><code>方式一：进入容器后打开一个新的终端，可以在里面操作docker exec -it 容器id bashShell方式二：进入容器正在执行的终端，不会启动新的进程docker attach 容器id</code></pre><h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><pre><code>docker cp 容器id：容器内路径 目的的主机路径Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</code></pre><p><img src="G:\xmind&md\imgs\1591748874380.png" alt="1591748874380"></p><pre><code>拷贝是一个手动过程，未来使用-v 卷的技术，可以实现自动更新主机的数据</code></pre><h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><h5 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h5><pre><code>利用docker安装nginx1.搜索nginx docker search nginx2.下载nginx docker pull nginx3.启动nginx docker run -d --name nginx01 -p 3344:80 nginx                   后台运行 起别名          将主机3344端口映射到容器80端口4.本机自测 curl localhost：33445.进入容器 docker exec -it ngnix01 /bin/bash</code></pre><h5 id="2-安装tomcat"><a href="#2-安装tomcat" class="headerlink" title="2.安装tomcat"></a>2.安装tomcat</h5><pre><code>1.docker pull tomcat2.docker run -rm --name tomcat01 -p 8099:8080 tomcat //测试完成后就删除，不建议使用3.curl localhost:8099 //因为是阉割版所以会报4044.docker exec -it tomcat01 /bin/bash 进入容器发现linux命令不全，tomcat中的webapps目录下没有网页5.cp -r webapps.dist/* webapps 将 webapps.dist的网页复制到webapps中</code></pre><h5 id="3-部署es-kibanas"><a href="#3-部署es-kibanas" class="headerlink" title="3.部署es+kibanas"></a>3.部署es+kibanas</h5><pre class=" language-shell"><code class="language-shell">1.docker pull elasticsearch 2.docker run -d -name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.23.docker stats 查看cpu状态4.增加内存限制，-e 环境配置修改docker run -d -name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2最多64兆，最大512兆</code></pre><pre><code>Xms 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。Xss 是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。</code></pre><p><img src="G:\xmind&md\imgs\1591753677271.png" alt="1591753677271"></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>portainer，docker图形化管理工具，提供一个后台面板供我们操作</p><pre><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><blockquote><p>软件包: 含 运行某个软件所需的所有的内容(代码,库,环境变量)</p><p>所有的应用,直接打包——-&gt;&gt;&gt;&gt;镜像</p></blockquote><h3 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h3><h4 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS (联合文件系统)"></a>UnionFS (联合文件系统)</h4><p>就是个文件,像git一样用版本控制纪录下,一次次叠加,呈现的是一个独立的文件—&gt;&gt;docker镜像</p><p>公用重复的东西(例如linux内核啊,这东西根本就不必重复下载 )</p><p>一层一层一层的构成UnionFS</p><p><strong>bootfs</strong> : bootloader(主引导加载) 包含boot加载器和内核 当boot加载完毕后整个内核就都在内存中了,此时内存的主导权就交给了内核,此时bootfs就会被卸载</p><p><strong>rootfs</strong> : 它在bootfs之上,包含各种不同的操作系统发行版,即:/dev/proc/etc等文件</p><p>这东西就是个精简再精简的iso文件.它只包含基本的命令,工具和程序库就ok了,</p><p>底层直接调用host的kernel，这就解释了为什么虚拟机与docker相比非常慢</p><p>因为虚拟机要加载bootfs这层文件,通过它来完成整个系统,但docker只需要寄生在宿主机上,用它的内核调用自己的rootfs文夹,完成,就ok了,,,,实现秒级启动</p><p><img src="G:\xmind&md\imgs\1591754978465.png" alt="1591754978465"></p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><pre><code>docker commit 提交容器成为一个新的副本docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]例如docker commit -m=&quot;add webapps&quot; -a=&quot;ks&quot; ******* tomcat02:[1.0]</code></pre><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>容器之间可以有一个数据共享的技术，在docker容器中产生的数据，同步到本地。</p><p>这就是卷技术，将我们容器内的目录挂载在linux上面。</p><p>为了容器的持久化和同步操作，容器间也是可以数据共享的。</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><pre><code>docker run -it -v /home/ceshi:/home centos /bin/bash双向绑定，主机修改，容器内部也同步改变；反过来也一样。</code></pre><p>测试配置，mysql</p><pre><code>docker pull mysql:5.7docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=z111111 -d mysql:tag例如：docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=z111111 -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql mysql:5.7</code></pre><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><h4 id="匿名加载"><a href="#匿名加载" class="headerlink" title="匿名加载"></a>匿名加载</h4><pre><code>-v 容器内路径docker run -d -P --name -v /etc/nginx nginx 只写了容器内的名字，没有写主机对应的目录</code></pre><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><pre><code>-v 卷名:容器内路径</code></pre><p><img src="G:\xmind&md\imgs\1591758838981.png" alt="1591758838981"></p><p>所有的docker容器内的卷，没有指定目录的情况下都是默认挂载在主机的”/var/lib/docker/volumes”目录下</p><p><img src="G:\xmind&md\imgs\1591759293224.png" alt="1591759293224"></p><h3 id="初识DockerFile"><a href="#初识DockerFile" class="headerlink" title="初识DockerFile"></a>初识DockerFile</h3><blockquote><p>方式二：使用DockerFile构建docker镜像的构建文件</p></blockquote><p><img src="G:\xmind&md\imgs\1591759751919.png" alt="1591759751919"></p><p><img src="G:\xmind&md\imgs\1591759841222.png" alt="1591759841222"></p><pre><code>使用docker inspect 容器ID查看挂载情况</code></pre><p><img src="G:\xmind&md\imgs\1591759954926.png" alt="1591759954926"></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>两个容器间数据共享</p><p><img src="G:\xmind&md\imgs\1591760154907.png" alt="1591760154907"></p><p><img src="G:\xmind&md\imgs\1591760339175.png" alt="1591760339175"></p><p>docker01的volume01、02挂载到了docker02容器内了。都是双向绑定、复制。父容器删除，子容器仍然有数据</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>用来构建docker镜像的文件</p><p>1.编写一个dockerfile文件</p><p>2.docker build构建成为一个镜像</p><p>3.docker run运行容器</p><p>4.docker push发布镜像</p><h3 id="docker构建过程"><a href="#docker构建过程" class="headerlink" title="docker构建过程"></a>docker构建过程</h3><p>基础知识：</p><p>1.保留关键字都必须大写字母</p><p>2.执行从上到下</p><p>3.#表示注释</p><p>4.每个指令都会创建提交一个新的镜像层并提交</p><p><img src="G:\xmind&md\imgs\1591761311841.png" alt="1591761311841"></p><p>docker是面向开发的，以后发布项目，做镜像需要编写dockerfile文件。</p><h3 id="docker指令"><a href="#docker指令" class="headerlink" title="docker指令"></a>docker指令</h3><p><img src="G:\xmind&md\imgs\1591761503342.png" alt="1591761503342"></p><p><img src="G:\xmind&md\imgs\1591767804838.png" alt="1591767804838"></p><h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><p>docker hub99%都是从FROM scratch开始的</p><pre><code>FROM scratchADD centos-7-x86_64-docker.tar.xz /LABEL \    org.label-schema.schema-version=&quot;1.0&quot; \    org.label-schema.name=&quot;CentOS Base Image&quot; \    org.label-schema.vendor=&quot;CentOS&quot; \    org.label-schema.license=&quot;GPLv2&quot; \    org.label-schema.build-date=&quot;20200504&quot; \    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \    org.opencontainers.image.vendor=&quot;CentOS&quot; \    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \    org.opencontainers.image.created=&quot;2020-05-04 00:00:00+01:00&quot;CMD [&quot;/bin/bash&quot;]</code></pre><h4 id="创建自己的centos镜像"><a href="#创建自己的centos镜像" class="headerlink" title="创建自己的centos镜像"></a>创建自己的centos镜像</h4><p>1.创建基本docker配置文件</p><pre><code>FROM centosMAINTAINER YMENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSEE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash</code></pre><p>2.构建自己的镜像</p><pre><code>docker build -f mydockerfile -t mycentos:0.1 .</code></pre><h5 id="CMD和ENTRYPOINT区别"><a href="#CMD和ENTRYPOINT区别" class="headerlink" title="CMD和ENTRYPOINT区别"></a>CMD和ENTRYPOINT区别</h5><p><img src="G:\xmind&md\imgs\1591769429417.png" alt="1591769429417"></p><p>使用entrypoint可以追加</p><h4 id="创建自己的tomca镜像"><a href="#创建自己的tomca镜像" class="headerlink" title="创建自己的tomca镜像"></a>创建自己的tomca镜像</h4><p>1.准备镜像文件tomcat压缩包，jdk的压缩包</p><p><img src="G:\xmind&md\imgs\1591770035554.png" alt="1591770035554"></p><p>2.编写dockerfile文件</p><p>add 会自动解压到local目录下</p><pre><code>FROM centosMAINTAINER YMADD jdk-12.0.2_linux-x64_bin.tar.gz /usr/local/ ADD apache-tomcat-9.0.24.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV  JAVA_HOME /usr/loacl/jdk12ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOEM/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.24ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.24ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.24/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.24/bin/logs/catalina.out</code></pre><p>3.运行dockerfile</p><pre><code>docker build -t diytomcat .</code></pre><h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><h2 id="Docker网络原理"><a href="#Docker网络原理" class="headerlink" title="Docker网络原理"></a>Docker网络原理</h2><h3 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h3><p>清空所有环境</p><pre><code>docker rm -f $(docker ps -aq)docker rmi -f $(docker images -aq)</code></pre><p><img src="G:\xmind&md\imgs\1591774220959.png" alt="1591774220959"></p><p>docker是如何处理容器网络连接的</p><p><img src="G:\xmind&md\imgs\1591774313193.png" alt="1591774313193"></p><p>每个容器docker会自动分配一个ip地址，主机可以ping通容器的ip。我们只要安装了docker，就会有一个网卡docker0，使用桥接模式连接网络，使用的技术是evth-pair。</p><p>容器带来的网卡都是一对的，veth-pair就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连。正是利用这个特性，veth-pair充当桥梁，连接各种虚拟网络设备。</p><p><img src="G:\xmind&md\imgs\1591775358978.png" alt="1591775358978"></p><p>当项目重启时，数据库ip就会发生改变，我们希望能通过服务名称来连接数据库。</p><pre><code>docker run -d -P --name tomcat03 --link tomcat02 tomcat这样就可以直接使用服务名ping通docker exec -it tomcat03 ping tomcat02</code></pre><p>本质就是–link在我们配置增加了一个172.18.0.3 tomcat02 2122123123dasd</p><p>现在不建议使用–link</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre><code>查看所有的docker网络</code></pre><p><img src="G:\xmind&md\imgs\1591776912996.png" alt="1591776912996"></p><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>bridge：桥接 docker(默认)</p><p>none：不配置网络</p><p>host： 和主机共享网络</p><p>container： 容器内网络</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>docker run -d -P -name tomcat01 tomcatdocker run -d -P -name tomcat01 --net bridge tomcat 默认添加docker0docker0特点：默认，域名不能访问，--link可以打通连接我们可以自定义一个网络--driver bridge桥接模式--subnet 192.168.0.0/16 子网地址--gateway 192.168.0.1 mynet 网关docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code></pre><p><strong>将镜像发布到自己创建的网络下</strong></p><pre><code>docker run -d -P --name tomcat01 --net mynet tomcat 这样就可以通过名字ping通</code></pre><p>优点：</p><p>不同集群使用不同网络，保证集群式安全和健康的</p><h3 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h3><p><img src="G:\xmind&md\imgs\1591778462206.png" alt="1591778462206"></p><p><img src="G:\xmind&md\imgs\1591778490187.png" alt="1591778490187"></p><pre><code>docker network connect [OPTIONS] NETWORK CONTAINER</code></pre><blockquote><p>测试打通 docker0下的tomcat01连接mynet下的tomcat-net-01</p><p>实质上是将tomcat01放到mynet网络下，使一个容器两个ip地址</p></blockquote><pre><code>docker network connect mynet tomcat01docker exec -it tomcat01 ping tomcat-net-01</code></pre><h2 id="IDEA整合docker"><a href="#IDEA整合docker" class="headerlink" title="IDEA整合docker"></a>IDEA整合docker</h2><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><h2 id="Docker-swarm"><a href="#Docker-swarm" class="headerlink" title="Docker swarm"></a>Docker swarm</h2><h2 id="CI-CD-Jenkins"><a href="#CI-CD-Jenkins" class="headerlink" title="CI\CD Jenkins"></a>CI\CD Jenkins</h2>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="2020/09/22/webpack/"/>
      <url>2020/09/22/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a>webpack 是什么</h2><p>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p><h2 id="webpack-五个核心概念"><a href="#webpack-五个核心概念" class="headerlink" title="webpack 五个核心概念"></a>webpack 五个核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>Loader 让 webpack 能够去处理那些非 JavaScript 文件(webpack 自身只理解JavaScript)</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</p><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>模式(Mode)指示 webpack 使用相应模式的配置。</p><table><thead><tr><th>选项</th><th>描述</th><th>特点</th></tr></thead><tbody><tr><td>development</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和NamedModulesPlugin。</td><td>能让代码本地调试运行的环境</td></tr><tr><td>production</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin,FlagIncludedChunksPlugin, ModuleConcatenationPlugin,NoEmitOnErrorsPlugin, OccurrenceOrderPlugin,SideEffectsFlagPlugin 和 TerserPlugin。</td><td>能让代码优化上线运行的环境d</td></tr></tbody></table><h2 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h2><pre><code>1. 运行指令：    开发环境：webpack ./src/index.js -o ./build/built.js --mode=development      webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js      整体打包环境，是开发环境    生产环境：webpack ./src/index.js -o ./build/built.js --mode=production      webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js      整体打包环境，是生产环境   2. 结论：    1. webpack能处理js/json资源，不能处理css/img等其他资源    2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~    3. 生产环境比开发环境多一个压缩js代码。</code></pre><h2 id="打包样式文件"><a href="#打包样式文件" class="headerlink" title="打包样式文件"></a>打包样式文件</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*  webpack.config.js  webpack的配置文件    作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）    所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs。*/</span><span class="token comment" spellcheck="true">// resolve用来拼接绝对路径的方法</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> resolve <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// webpack配置</span>  <span class="token comment" spellcheck="true">// 入口起点</span>  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 输出</span>  output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出文件名</span>    filename<span class="token punctuation">:</span> <span class="token string">'built.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 输出路径</span>    <span class="token comment" spellcheck="true">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span>    path<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// loader的配置</span>  module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token comment" spellcheck="true">// 详细loader配置</span>      <span class="token comment" spellcheck="true">// 不同文件必须配置不同loader处理</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 匹配哪些文件</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 使用哪些loader进行处理</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token comment" spellcheck="true">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span>          <span class="token comment" spellcheck="true">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span>          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span>          <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.less$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>          <span class="token string">'css-loader'</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 将less文件编译成css文件</span>          <span class="token comment" spellcheck="true">// 需要下载 less-loader和less</span>          <span class="token string">'less-loader'</span>        <span class="token punctuation">]</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// plugins的配置</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">// 详细plugins的配置</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 模式</span>  mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 开发模式</span>  <span class="token comment" spellcheck="true">// mode: 'production'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="webpack打包报错"><a href="#webpack打包报错" class="headerlink" title="webpack打包报错"></a>webpack打包报错</h3><pre><code>首先在项目根目录下创建名为：webpack.config.js文件const path = require(&#39;path&#39;)module.exports = &#123;    //指定入口，表示webpack要打包哪个文件    entry: path.join(__dirname,&#39;./src/main.js&#39;),    //指定出口，表示打包好的文件输出到哪个目录    output:&#123;        path:path.join(__dirname,&#39;./dist&#39;),        //指定输出文件的名称        filename:&#39;bundle1.js&#39;    &#125;&#125;</code></pre><p>下载依赖</p><blockquote><p>npm i css-loader style-loader -D</p></blockquote><p>这样就能打包css样式资源了</p><blockquote><p>npm i less less-loader -D</p></blockquote><p>可以打包less资源</p><h3 id="打包html文件"><a href="#打包html文件" class="headerlink" title="打包html文件"></a>打包html文件</h3><blockquote><p>npm i html-webpack-plugin -D</p></blockquote><pre><code> plugins: [    // plugins的配置    // html-webpack-plugin    // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）    // 需求：需要有结构的HTML文件    new HtmlWebpackPlugin(&#123;      // 复制 &#39;./src/index.html&#39; 文件，并自动引入打包输出的所有资源（JS/CSS）      template: &#39;./src/index.html&#39;    &#125;)  ]</code></pre><h3 id="打包图片资源"><a href="#打包图片资源" class="headerlink" title="打包图片资源"></a>打包图片资源</h3><pre><code>module: &#123;    rules: [      &#123;        test: /\.less$/,        // 要使用多个loader处理用use        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      &#125;,      &#123;        // 问题：默认处理不了html中img图片        // 处理图片资源        test: /\.(jpg|png|gif)$/,        // 使用一个loader        // 下载 url-loader file-loader        loader: &#39;url-loader&#39;,        options: &#123;          // 图片大小小于8kb，就会被base64处理          // 优点: 减少请求数量（减轻服务器压力）          // 缺点：图片体积会更大（文件请求速度更慢）          limit: 8 * 1024,          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs          // 解析时会出问题：[object Module]          // 解决：关闭url-loader的es6模块化，使用commonjs解析          esModule: false,          // 给图片进行重命名          // [hash:10]取图片的hash的前10位          // [ext]取文件原来扩展名          name: &#39;[hash:10].[ext]&#39;        &#125;      &#125;,      &#123;        test: /\.html$/,        // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）        loader: &#39;html-loader&#39;      &#125;    ]  &#125;</code></pre><h3 id="打包其他资源"><a href="#打包其他资源" class="headerlink" title="打包其他资源"></a>打包其他资源</h3><pre><code>module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]      &#125;,      // 打包其他资源(除了html/js/css资源以外的资源)      &#123;        // 排除css/js/html资源        exclude: /\.(css|js|html|less)$/,        loader: &#39;file-loader&#39;,        options: &#123;          name: &#39;[hash:10].[ext]&#39;        &#125;      &#125;    ]  &#125;</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;span class=&quot;iconfont icon-icon-test&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test2&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test3&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;iconfont icon-icon-test1&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>js，css会被</p><pre><code>plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;)  ]</code></pre><p>自动引入</p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~</p><p>首先下载依赖， npm i webpack-dev-server -D</p><pre><code> mode: &#39;development&#39;,  // 开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）  // 特点：只会在内存中编译打包，不会有任何输出  // 启动devServer指令为：npx webpack-dev-server  devServer: &#123;    // 项目构建后路径    contentBase: resolve(__dirname, &#39;build&#39;),    // 启动gzip压缩    compress: true,    // 端口号    port: 3000,    // 自动打开浏览器    open: true  &#125;</code></pre><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>webpack.config.js</p><pre><code>/*  开发环境配置：能让代码运行    运行项目指令：      webpack 会将打包结果输出出去      npx webpack-dev-server 只会在内存中编译打包，没有输出*/const &#123; resolve &#125; = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;  entry: &#39;./src/js/index.js&#39;,  output: &#123;    filename: &#39;js/built.js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;,  module: &#123;    rules: [      // loader的配置      &#123;        // 处理less资源        test: /\.less$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      &#125;,      &#123;        // 处理css资源        test: /\.css$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]      &#125;,      &#123;        // 处理图片资源        test: /\.(jpg|png|gif)$/,        loader: &#39;url-loader&#39;,        options: &#123;          limit: 8 * 1024,          name: &#39;[hash:10].[ext]&#39;,          // 关闭es6模块化          esModule: false,          outputPath: &#39;imgs&#39;        &#125;      &#125;,      &#123;        // 处理html中img资源        test: /\.html$/,        loader: &#39;html-loader&#39;      &#125;,      &#123;        // 处理其他资源        exclude: /\.(html|js|css|less|jpg|png|gif)/,        loader: &#39;file-loader&#39;,        options: &#123;          name: &#39;[hash:10].[ext]&#39;,          outputPath: &#39;media&#39;        &#125;      &#125;    ]  &#125;,  plugins: [    // plugins的配置    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;)  ],  mode: &#39;development&#39;,  devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true  &#125;&#125;;</code></pre><p>创建src目录，src下再创建index.html,index.js</p><h2 id="webpack-生产环境的基本配置"><a href="#webpack-生产环境的基本配置" class="headerlink" title="webpack 生产环境的基本配置"></a>webpack 生产环境的基本配置</h2><h3 id="提取-css-成单独文件"><a href="#提取-css-成单独文件" class="headerlink" title="提取 css 成单独文件"></a>提取 css 成单独文件</h3><blockquote><p>下载插件<br>npm install –save-dev mini-css-extract-plugin -D</p></blockquote><pre><code>const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [          // 创建style标签，将样式放入          // &#39;style-loader&#39;,           // 这个loader取代style-loader。作用：提取js中的css成单独文件          MiniCssExtractPlugin.loader,          // 将css文件整合到js文件中          &#39;css-loader&#39;        ]      &#125;    ]  &#125;，  plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;),    new MiniCssExtractPlugin(&#123;      // 对输出的css文件进行重命名      filename: &#39;css/built.css&#39;    &#125;)  ],</code></pre><h3 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h3><blockquote><p>下载依赖 npm i postcss-loader postcss-preset-env -D</p></blockquote><pre><code>module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          /*            css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式          */          // 使用loader的默认配置          // &#39;postcss-loader&#39;,          // 修改loader的配置          &#123;            loader: &#39;postcss-loader&#39;,            options: &#123;              ident: &#39;postcss&#39;,              plugins: () =&gt; [                // postcss的插件                require(&#39;postcss-preset-env&#39;)()              ]            &#125;          &#125;        ]      &#125;    ]  &#125;</code></pre><p>在package.json添加browserslist</p><pre><code>&quot;browserslist&quot;: &#123;    &quot;development&quot;: [   // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ],    &quot;production&quot;: [ // 生产环境：默认是看生产环境      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ]  &#125;</code></pre><p>在webpack.config.js设置node环境为开发环境</p><pre><code>process.env.NODE_ENV = &#39;development&#39;</code></pre><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><blockquote><p>下载安装包<br>npm install –save-dev optimize-css-assets-webpack-plugin</p></blockquote><pre><code>const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;    &#125;),    new MiniCssExtractPlugin(&#123;      filename: &#39;css/built.css&#39;    &#125;),    // 压缩css    new OptimizeCssAssetsWebpackPlugin()  ]</code></pre><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><blockquote><p> 下载安装包<br>npm install –save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import -D</p></blockquote><pre><code>module: &#123;    rules: [      /*        语法检查： eslint-loader  eslint          注意：只检查自己写的源代码，第三方的库是不用检查的          设置检查规则：            airbnb --&gt; eslint-config-airbnb-base  eslint-plugin-import eslint      */      &#123;        test: /\.js$/,        exclude: /node_modules/, // 第三方的库是不用检查的        loader: &#39;eslint-loader&#39;,        options: &#123;          // 自动修复eslint的错误          fix: true        &#125;      &#125;    ]  &#125;</code></pre><p>package.json中eslintConfig中设置</p><pre><code>&quot;eslintConfig&quot;: &#123;    &quot;extends&quot;: &quot;airbnb-base&quot;,    &quot;env&quot;: &#123;      &quot;browser&quot;: true    &#125;  &#125;</code></pre><p>index.js</p><pre><code>// 下一行eslint所有规则都失效（下一行不进行eslint检查）// eslint-disable-next-lineconsole.log(add(2, 5));</code></pre><h3 id="js兼容性配置"><a href="#js兼容性配置" class="headerlink" title="js兼容性配置"></a>js兼容性配置</h3><p> 下载安装包<br>npm install –save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill core-js</p><pre><code>module: &#123;    rules: [      /*        js兼容性处理：babel-loader @babel/core           1. 基本js兼容性处理 --&gt; @babel/preset-env            问题：只能转换基本语法，如promise高级语法不能转换          2. 全部js兼容性处理 --&gt; @babel/polyfill              在index.js 下   import &#39;@babel/polyfill&#39;;            问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js      */        &#123;        test: /\.js$/,        exclude: /node_modules/,        loader: &#39;babel-loader&#39;,        options: &#123;          // 预设：指示babel做怎么样的兼容性处理          presets: [            [              &#39;@babel/preset-env&#39;,              &#123;                // 按需加载                useBuiltIns: &#39;usage&#39;,                // 指定core-js版本                corejs: &#123;                  version: 3                &#125;,                // 指定兼容性做到哪个版本浏览器                targets: &#123;                  chrome: &#39;60&#39;,                  firefox: &#39;60&#39;,                  ie: &#39;9&#39;,                  safari: &#39;10&#39;,                  edge: &#39;17&#39;                &#125;              &#125;            ]          ]        &#125;      &#125;    ]  &#125;</code></pre><h3 id="js的压缩"><a href="#js的压缩" class="headerlink" title="js的压缩"></a>js的压缩</h3><p>生产环境下会自动压缩js代码</p><h3 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h3><pre><code>plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;,      // 压缩html代码      minify: &#123;        // 移除空格        collapseWhitespace: true,        // 移除注释        removeComments: true      &#125;    &#125;)  ]</code></pre><h3 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h3><pre><code>const &#123; resolve &#125; = require(&#39;path&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); // 将css单独提取const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);// 定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV = &#39;production&#39;;// 复用loaderconst commonCssLoader = [ // css兼容配置  MiniCssExtractPlugin.loader,  &#39;css-loader&#39;,  &#123;    // 还需要在package.json中定义browserslist    loader: &#39;postcss-loader&#39;,    options: &#123;      ident: &#39;postcss&#39;,      plugins: () =&gt; [require(&#39;postcss-preset-env&#39;)()]    &#125;  &#125;];module.exports = &#123;  entry: &#39;./src/js/index.js&#39;,  output: &#123;    filename: &#39;js/built.js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [...commonCssLoader]      &#125;,      &#123;        test: /\.less$/,        use: [...commonCssLoader, &#39;less-loader&#39;]      &#125;,      /*        正常来讲，一个文件只能被一个loader处理。        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：          先执行eslint 在执行babel      */      &#123;        // 在package.json中eslintConfig --&gt; airbnb        test: /\.js$/,        exclude: /node_modules/,        // 优先执行        enforce: &#39;pre&#39;, //  先执行eslint 在执行babel        loader: &#39;eslint-loader&#39;,        options: &#123;          fix: true        &#125;      &#125;,      &#123;        test: /\.js$/,        exclude: /node_modules/,        loader: &#39;babel-loader&#39;,        options: &#123;          presets: [            [              &#39;@babel/preset-env&#39;,              &#123;                useBuiltIns: &#39;usage&#39;,                corejs: &#123;version: 3&#125;,                targets: &#123;                  chrome: &#39;60&#39;,                  firefox: &#39;50&#39;                &#125;              &#125;            ]          ]        &#125;      &#125;,      &#123;        test: /\.(jpg|png|gif)/,        loader: &#39;url-loader&#39;,        options: &#123;          limit: 8 * 1024,          name: &#39;[hash:10].[ext]&#39;,          outputPath: &#39;imgs&#39;,          esModule: false        &#125;      &#125;,      &#123;        test: /\.html$/,        loader: &#39;html-loader&#39;      &#125;,      &#123;        exclude: /\.(js|css|less|html|jpg|png|gif)/,        loader: &#39;file-loader&#39;,        options: &#123;          outputPath: &#39;media&#39;        &#125;      &#125;    ]  &#125;,  plugins: [    new MiniCssExtractPlugin(&#123; // 将css单独提取      filename: &#39;css/built.css&#39;    &#125;),    new OptimizeCssAssetsWebpackPlugin(),    new HtmlWebpackPlugin(&#123;      template: &#39;./src/index.html&#39;,      minify: &#123;        collapseWhitespace: true,        removeComments: true      &#125;    &#125;)  ],  mode: &#39;production&#39;&#125;;</code></pre><pre><code>目前示例中webpack使用css方式：css-loader：将js中的css内容解析style-loader：最终将css样式通过&lt;style&gt;标签方式注入到页面中。CSS内容还是存储在JS文件中。MiniCssExtractPlugin 插件可以将CSS内容从打包结果中提取出来，存放到文件中。通过这个插件，就可以实现CSS模块的按需加载。因为提取后生成了css文件，所以就不需要&lt;style&gt;标签，而是直接通过&lt;link&gt;的方式引入。所以使用MiniCssExtractPlugin，就不需要style-loader，而是使用插件提供的loader实现通过&lt;link&gt;标签的方式注入。</code></pre><p> <a href="https://blog.csdn.net/astonishqft/article/details/82899965">https://blog.csdn.net/astonishqft/article/details/82899965</a> </p><h3 id="output中path、publicPath的区别"><a href="#output中path、publicPath的区别" class="headerlink" title="output中path、publicPath的区别"></a>output中path、publicPath的区别</h3><p>解决css提取出来后，img不加载问题</p><h2 id="webpack性能优化"><a href="#webpack性能优化" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h2><ul><li>开发环境性能优化</li><li>生产环境性能优化</li></ul><h3 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h3><ul><li>优化打包构建速度<ul><li>HMR</li></ul></li><li>优化代码调试<ul><li>source-map</li></ul></li></ul><h3 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h3><ul><li>优化打包构建速度<ul><li>oneOf</li><li>babel缓存</li><li>多进程打包</li><li>externals</li><li>dll</li></ul></li><li>优化代码运行的性能<ul><li>缓存(hash-chunkhash-contenthash)</li><li>tree shaking</li><li>code split</li><li>懒加载/预加载</li><li>pwa</li></ul></li></ul><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><p>HMR: hot module replacement 热模块替换 / 模块热替换<br>    作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 极大提升构建速度</p><p>  样式文件：可以使用HMR功能：因为style-loader内部实现了~<br>  js文件：默认不能使用HMR功能 –&gt; 需要修改js代码，添加支持HMR功能的代码<br>    注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。<br>    html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~ （不用做HMR功能）<br>    解决：修改entry入口，将html文件引入 </p><blockquote><p>entry: [‘./src/js/index.js’, ‘./src/index.html’],</p></blockquote><pre><code>devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true,    // 开启HMR功能    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务    hot: true  &#125;</code></pre><h4 id="index-js开启热更新"><a href="#index-js开启热更新" class="headerlink" title="index.js开启热更新"></a>index.js开启热更新</h4><pre><code>if (module.hot) &#123;  // 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效  module.hot.accept(&#39;./print.js&#39;, function() &#123;    // 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。    // 会执行后面的回调函数    print();  &#125;);</code></pre><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误</p><pre><code>devServer: &#123;    contentBase: resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,    open: true,    hot: true  &#125;,  devtool: &#39;eval-source-map&#39;</code></pre><pre><code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map    source-map：外部      错误代码准确信息 和 源代码的错误位置    inline-source-map：内联      只生成一个内联source-map      错误代码准确信息 和 源代码的错误位置    hidden-source-map：外部      错误代码错误原因，但是没有错误位置      不能追踪源代码错误，只能提示到构建后代码的错误位置    eval-source-map：内联      每一个文件都生成对应的source-map，都在eval      错误代码准确信息 和 源代码的错误位置    nosources-source-map：外部      错误代码准确信息, 但是没有任何源代码信息    cheap-source-map：外部      错误代码准确信息 和 源代码的错误位置       只能精确的行    cheap-module-source-map：外部      错误代码准确信息 和 源代码的错误位置       module会将loader的source map加入    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快    开发环境：速度快，调试更友好      速度快(eval&gt;inline&gt;cheap&gt;...)        eval-cheap-souce-map        eval-source-map      调试更友好          souce-map        cheap-module-souce-map        cheap-souce-map      --&gt; eval-source-map  / eval-cheap-module-souce-map    生产环境：源代码要不要隐藏? 调试要不要更友好      内联会让代码体积变大，所以在生产环境不用内联      nosources-source-map 全部隐藏      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息      --&gt; source-map / cheap-module-souce-map</code></pre><h3 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h3><p>提升构建速度，所有loader只判断一次</p><pre><code>module: &#123;    rules: [      &#123;        // 在package.json中eslintConfig --&gt; airbnb        test: /\.js$/,        exclude: /node_modules/,        // 优先执行        enforce: &#39;pre&#39;,        loader: &#39;eslint-loader&#39;,        options: &#123;          fix: true        &#125;      &#125;,      &#123;        // 以下loader只会匹配一个        // 注意：不能有两个配置处理同一种类型文件        oneOf: [          &#123;            test: /\.css$/,            use: [...commonCssLoader]          &#125;,          &#123;            test: /\.less$/,            use: [...commonCssLoader, &#39;less-loader&#39;]          &#125;,          /*            正常来讲，一个文件只能被一个loader处理。            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：              先执行eslint 在执行babel          */          &#123;            test: /\.js$/,            exclude: /node_modules/,            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                [                  &#39;@babel/preset-env&#39;,                  &#123;                    useBuiltIns: &#39;usage&#39;,                    corejs: &#123;version: 3&#125;,                    targets: &#123;                      chrome: &#39;60&#39;,                      firefox: &#39;50&#39;                    &#125;                  &#125;                ]              ]            &#125;          &#125;,          &#123;            test: /\.(jpg|png|gif)/,            loader: &#39;url-loader&#39;,            options: &#123;              limit: 8 * 1024,              name: &#39;[hash:10].[ext]&#39;,              outputPath: &#39;imgs&#39;,              esModule: false            &#125;          &#125;,          &#123;            test: /\.html$/,            loader: &#39;html-loader&#39;          &#125;,          &#123;            exclude: /\.(js|css|less|html|jpg|png|gif)/,            loader: &#39;file-loader&#39;,            options: &#123;              outputPath: &#39;media&#39;            &#125;          &#125;        ]      &#125;    ]  &#125;</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="babel缓存"><a href="#babel缓存" class="headerlink" title="babel缓存"></a>babel缓存</h4><blockquote><p>cacheDirectory: true –&gt; 让第二次打包构建速度更快</p></blockquote><pre><code>&#123;            test: /\.js$/,            exclude: /node_modules/,            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                [                  &#39;@babel/preset-env&#39;,                  &#123;                    useBuiltIns: &#39;usage&#39;,                    corejs: &#123; version: 3 &#125;,                    targets: &#123;                      chrome: &#39;60&#39;,                      firefox: &#39;50&#39;                    &#125;                  &#125;                ]              ],              // 开启babel缓存              // 第二次构建时，会读取之前的缓存              cacheDirectory: true            &#125;          &#125;</code></pre><h4 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h4><pre><code>/*  服务器代码  启动服务器指令：    npm i nodemon -g    nodemon server.js    node server.js  访问服务器地址：    http://localhost:3000*/const express = require(&#39;express&#39;);const app = express();// express.static向外暴露静态资源// maxAge 资源缓存的最大时间，单位msapp.use(express.static(&#39;build&#39;, &#123; maxAge: 1000 * 3600 &#125;));app.listen(3000);</code></pre><h4 id="文件资源缓存"><a href="#文件资源缓存" class="headerlink" title="文件资源缓存"></a>文件资源缓存</h4><pre><code> hash: 每次wepack构建时会生成一个唯一的hash值。        问题: 因为js和css同时使用一个hash值。          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件） chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样        问题: js和css的hash值还是一样的          因为css是在js中被引入的，所以同属于一个chunkcontenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样          --&gt; 让代码上线运行缓存更好使用</code></pre><h3 id="tree-shaking-树摇"><a href="#tree-shaking-树摇" class="headerlink" title="tree shaking 树摇"></a>tree shaking 树摇</h3><pre><code>tree shaking：去除无用代码    前提：1. 必须使用ES6模块化  2. 开启production环境    作用: 减少代码体积    在package.json中配置       &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）        问题：可能会把css / @babel/polyfill （副作用）文件干掉      &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code></pre><h3 id="code-split代码分割"><a href="#code-split代码分割" class="headerlink" title="code split代码分割"></a>code split代码分割</h3><pre><code>// 单入口  // entry: &#39;./src/js/index.js&#39;,  entry: &#123;    // 多入口：有一个入口，最终输出就有一个bundle    index: &#39;./src/js/index.js&#39;,    test: &#39;./src/js/test.js&#39;  &#125;,  output: &#123;    // [name]：取文件名    filename: &#39;js/[name].[contenthash:10].js&#39;,    path: resolve(__dirname, &#39;build&#39;)  &#125;</code></pre><blockquote><p>第二种配置</p></blockquote><pre><code>/*    1. 可以将node_modules中代码单独打包一个chunk最终输出    2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk  */  optimization: &#123;    splitChunks: &#123;      chunks: &#39;all&#39;    &#125;  &#125;,</code></pre><h3 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h3><pre><code>document.getElementById(&#39;btn&#39;).onclick = function() &#123;  // 懒加载~：当文件需要使用时才加载~  // 预加载 prefetch：会在使用之前，提前加载js文件   // 正常加载可以认为是并行加载（同一时间加载多个文件）    // 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源  import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./test&#39;).then((&#123; mul &#125;) =&gt; &#123;    console.log(mul(4, 5));  &#125;);&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
